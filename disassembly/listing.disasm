Disassembly Listing for ledmatrix_ws2812
Generated From:
/Users/MATHRAX/ledmatrix_ws2812/ledmatrix_ws2812/dist/default/production/ledmatrix_ws2812.production.elf
Mar 29, 2016 3:33:30 PM

---  /Users/MATHRAX/ledmatrix_ws2812/ledmatrix_ws2812/main.c  -------------------------------------------
1:                   // DEVCFG3:
2:                   #pragma config IOL1WAY  = OFF           // Peripheral Pin Select Configuration
3:                   // DEVCFG2:
4:                   #pragma config FPLLIDIV = DIV_2         // PLL Input Divider (2x Divider)
5:                   #pragma config FPLLMUL = MUL_16         // PLL Multiplier (24x Multiplier)
6:                   #pragma config FPLLODIV = DIV_1         // System PLL Output Clock Divider (PLL Divide by 1)
7:                   // DEVCFG1:
8:                   #pragma config FWDTEN   = OFF           // Watchdog Timer
9:                   #pragma config WDTPS    = PS1           // Watchdog Timer Postscale
10:                  #pragma config FCKSM    = CSDCMD        // Clock Switching & Fail Safe Clock Monitor
11:                  #pragma config FPBDIV   = DIV_1         // Peripheral Clock divisor
12:                  #pragma config OSCIOFNC = OFF           // CLKO Enable
13:                  #pragma config POSCMOD  = OFF           // Primary Oscillator
14:                  #pragma config IESO     = OFF           // Internal/External Switch-over
15:                  #pragma config FSOSCEN  = OFF           // Secondary Oscillator Enable (KLO was off)
16:                  #pragma config FNOSC    = FRCPLL        // Oscillator Selection
17:                  // DEVCFG0:
18:                  #pragma config CP       = OFF           // Code Protect
19:                  #pragma config BWP      = ON            // Boot Flash Write Protect
20:                  #pragma config PWP      = OFF           // Program Flash Write Protect
21:                  #pragma config ICESEL   = ICS_PGx3      // ICE/ICD Comm Channel Select
22:                  #pragma config JTAGEN   = OFF           // JTAG Enable
23:                  
24:                  #define SYSCLK 64000000L
25:                  #define FCY          SYSCLK
26:                  
27:                  #include <p32xxxx.h>
28:                  #include <plib.h>
29:                  #include "pattern.h"
30:                  
31:                  #define GetSystemClock()       (SYSCLK)
32:                  
33:                  #define neopixel_pin      LATBbits.LATB9
34:                  
35:                  unsigned char r[256];
36:                  unsigned char g[256];
37:                  unsigned char b[256];
38:                  
39:                  #define TRIS_TX1                TRISBbits.TRISB3
40:                  #define TRIS_RX1                TRISBbits.TRISB2
41:                  extern void resetAnimation();
42:                  
43:                  int count;
44:                  int pCount;
45:                  int aCnt;
46:                  int frameCount;
47:                  int firstReset;
48:                  
49:                  void NeoBit(int Bit) {
9D000000  27BDFFF8   ADDIU SP, SP, -8
9D000004  AFBE0004   SW S8, 4(SP)
9D000008  03A0F021   ADDU S8, SP, ZERO
9D00000C  AFC40008   SW A0, 8(S8)
50:                      int j;
51:                      if (Bit == 1) {
9D000010  8FC30008   LW V1, 8(S8)
9D000014  24020001   ADDIU V0, ZERO, 1
9D000018  14620051   BNE V1, V0, 0x9D000160
9D00001C  00000000   NOP
52:                          neopixel_pin = 1;
9D000020  3C03BF88   LUI V1, -16504
9D000024  8C626130   LW V0, 24880(V1)
9D000028  24040001   ADDIU A0, ZERO, 1
9D00002C  7C824A44   INS V0, A0, 9, 1
9D000030  AC626130   SW V0, 24880(V1)
53:                          Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
9D000034  00000040   SSNOP
9D000038  00000040   SSNOP
9D00003C  00000040   SSNOP
9D000040  00000040   SSNOP
9D000044  00000040   SSNOP
9D000048  00000040   SSNOP
9D00004C  00000040   SSNOP
9D000050  00000040   SSNOP
9D000054  00000040   SSNOP
9D000058  00000040   SSNOP
54:                          Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
9D00005C  00000040   SSNOP
9D000060  00000040   SSNOP
9D000064  00000040   SSNOP
9D000068  00000040   SSNOP
9D00006C  00000040   SSNOP
9D000070  00000040   SSNOP
9D000074  00000040   SSNOP
9D000078  00000040   SSNOP
9D00007C  00000040   SSNOP
9D000080  00000040   SSNOP
55:                          Nop();//Nop();
9D000084  00000040   SSNOP
56:                  
57:                          neopixel_pin = 0;
9D000088  3C03BF88   LUI V1, -16504
9D00008C  8C626130   LW V0, 24880(V1)
9D000090  7C024A44   INS V0, ZERO, 9, 1
9D000094  AC626130   SW V0, 24880(V1)
58:                          Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
9D000098  00000040   SSNOP
9D00009C  00000040   SSNOP
9D0000A0  00000040   SSNOP
9D0000A4  00000040   SSNOP
9D0000A8  00000040   SSNOP
9D0000AC  00000040   SSNOP
9D0000B0  00000040   SSNOP
9D0000B4  00000040   SSNOP
9D0000B8  00000040   SSNOP
9D0000BC  00000040   SSNOP
59:                          Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
9D0000C0  00000040   SSNOP
9D0000C4  00000040   SSNOP
9D0000C8  00000040   SSNOP
9D0000CC  00000040   SSNOP
9D0000D0  00000040   SSNOP
9D0000D4  00000040   SSNOP
9D0000D8  00000040   SSNOP
9D0000DC  00000040   SSNOP
9D0000E0  00000040   SSNOP
9D0000E4  00000040   SSNOP
60:                          Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
9D0000E8  00000040   SSNOP
9D0000EC  00000040   SSNOP
9D0000F0  00000040   SSNOP
9D0000F4  00000040   SSNOP
9D0000F8  00000040   SSNOP
9D0000FC  00000040   SSNOP
9D000100  00000040   SSNOP
9D000104  00000040   SSNOP
9D000108  00000040   SSNOP
9D00010C  00000040   SSNOP
61:                          Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
9D000110  00000040   SSNOP
9D000114  00000040   SSNOP
9D000118  00000040   SSNOP
9D00011C  00000040   SSNOP
9D000120  00000040   SSNOP
9D000124  00000040   SSNOP
9D000128  00000040   SSNOP
9D00012C  00000040   SSNOP
9D000130  00000040   SSNOP
9D000134  00000040   SSNOP
62:                          Nop();Nop();Nop();Nop();Nop();Nop();Nop();//Nop();Nop();Nop();
9D000138  00000040   SSNOP
9D00013C  00000040   SSNOP
9D000140  00000040   SSNOP
9D000144  00000040   SSNOP
9D000148  00000040   SSNOP
9D00014C  00000040   SSNOP
9D000150  00000040   SSNOP
63:                          Nop();
9D000154  00000040   SSNOP
9D000158  0B4000AD   J 0x9D0002B4
9D00015C  00000000   NOP
64:                          
65:                      }// delay_cycles (3); // Bit '1'   
66:                      else {
67:                          neopixel_pin = 1;
9D000160  3C03BF88   LUI V1, -16504
9D000164  8C626130   LW V0, 24880(V1)
9D000168  24040001   ADDIU A0, ZERO, 1
9D00016C  7C824A44   INS V0, A0, 9, 1
9D000170  AC626130   SW V0, 24880(V1)
68:                          Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
9D000174  00000040   SSNOP
9D000178  00000040   SSNOP
9D00017C  00000040   SSNOP
9D000180  00000040   SSNOP
9D000184  00000040   SSNOP
9D000188  00000040   SSNOP
9D00018C  00000040   SSNOP
9D000190  00000040   SSNOP
9D000194  00000040   SSNOP
9D000198  00000040   SSNOP
69:                          Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
9D00019C  00000040   SSNOP
9D0001A0  00000040   SSNOP
9D0001A4  00000040   SSNOP
9D0001A8  00000040   SSNOP
9D0001AC  00000040   SSNOP
9D0001B0  00000040   SSNOP
9D0001B4  00000040   SSNOP
9D0001B8  00000040   SSNOP
9D0001BC  00000040   SSNOP
9D0001C0  00000040   SSNOP
70:                          Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
9D0001C4  00000040   SSNOP
9D0001C8  00000040   SSNOP
9D0001CC  00000040   SSNOP
9D0001D0  00000040   SSNOP
9D0001D4  00000040   SSNOP
9D0001D8  00000040   SSNOP
9D0001DC  00000040   SSNOP
9D0001E0  00000040   SSNOP
9D0001E4  00000040   SSNOP
9D0001E8  00000040   SSNOP
71:                          Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
9D0001EC  00000040   SSNOP
9D0001F0  00000040   SSNOP
9D0001F4  00000040   SSNOP
9D0001F8  00000040   SSNOP
9D0001FC  00000040   SSNOP
9D000200  00000040   SSNOP
9D000204  00000040   SSNOP
9D000208  00000040   SSNOP
9D00020C  00000040   SSNOP
9D000210  00000040   SSNOP
72:                          Nop();//Nop();Nop();Nop();
9D000214  00000040   SSNOP
73:                          
74:                          neopixel_pin = 0;
9D000218  3C03BF88   LUI V1, -16504
9D00021C  8C626130   LW V0, 24880(V1)
9D000220  7C024A44   INS V0, ZERO, 9, 1
9D000224  AC626130   SW V0, 24880(V1)
75:                          Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
9D000228  00000040   SSNOP
9D00022C  00000040   SSNOP
9D000230  00000040   SSNOP
9D000234  00000040   SSNOP
9D000238  00000040   SSNOP
9D00023C  00000040   SSNOP
9D000240  00000040   SSNOP
9D000244  00000040   SSNOP
9D000248  00000040   SSNOP
9D00024C  00000040   SSNOP
76:                          Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
9D000250  00000040   SSNOP
9D000254  00000040   SSNOP
9D000258  00000040   SSNOP
9D00025C  00000040   SSNOP
9D000260  00000040   SSNOP
9D000264  00000040   SSNOP
9D000268  00000040   SSNOP
9D00026C  00000040   SSNOP
9D000270  00000040   SSNOP
9D000274  00000040   SSNOP
77:                          Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
9D000278  00000040   SSNOP
9D00027C  00000040   SSNOP
9D000280  00000040   SSNOP
9D000284  00000040   SSNOP
9D000288  00000040   SSNOP
9D00028C  00000040   SSNOP
9D000290  00000040   SSNOP
9D000294  00000040   SSNOP
9D000298  00000040   SSNOP
9D00029C  00000040   SSNOP
78:                          Nop();Nop();Nop();Nop();Nop();//Nop();Nop();Nop();
9D0002A0  00000040   SSNOP
9D0002A4  00000040   SSNOP
9D0002A8  00000040   SSNOP
9D0002AC  00000040   SSNOP
9D0002B0  00000040   SSNOP
79:                      } // delay_cycles (6); // Bit '0'   
80:                  }
9D0002B4  03C0E821   ADDU SP, S8, ZERO
9D0002B8  8FBE0004   LW S8, 4(SP)
9D0002BC  03E00008   JR RA
9D0002C0  27BD0008   ADDIU SP, SP, 8
81:                  
82:                  void Neopixel() {
9D0002C4  27BDFFE0   ADDIU SP, SP, -32
9D0002C8  AFBF001C   SW RA, 28(SP)
9D0002CC  AFBE0018   SW S8, 24(SP)
9D0002D0  03A0F021   ADDU S8, SP, ZERO
83:                      int i, j, k;
84:                      neopixel_pin = 0;
9D0002D4  3C03BF88   LUI V1, -16504
9D0002D8  8C626130   LW V0, 24880(V1)
9D0002DC  7C024A44   INS V0, ZERO, 9, 1
9D0002E0  AC626130   SW V0, 24880(V1)
85:                      for (j = 0; j < 320; j++) {
9D0002E4  0B4000BF   J 0x9D0002FC
9D0002E8  AFC00010   SW ZERO, 16(S8)
9D0002F0  8FC20010   LW V0, 16(S8)
9D0002F4  24420001   ADDIU V0, V0, 1
9D0002F8  AFC20010   SW V0, 16(S8)
9D0002FC  8FC20010   LW V0, 16(S8)
9D000300  28420140   SLTI V0, V0, 320
9D000304  1440FFF9   BNE V0, ZERO, 0x9D0002EC
9D000308  00000000   NOP
86:                          Nop();
9D0002EC  00000040   SSNOP
87:                      }
88:                  
89:                      //LEDs
90:                      for (j = 0; j < 256; j++) {
9D00030C  0B400144   J 0x9D000510
9D000310  AFC00010   SW ZERO, 16(S8)
9D000504  8FC20010   LW V0, 16(S8)
9D000508  24420001   ADDIU V0, V0, 1
9D00050C  AFC20010   SW V0, 16(S8)
9D000510  8FC20010   LW V0, 16(S8)
9D000514  28420100   SLTI V0, V0, 256
9D000518  1440FF7E   BNE V0, ZERO, 0x9D000314
9D00051C  00000000   NOP
91:                          int tmp = break_heart[j];
9D000314  3C029D00   LUI V0, -25344
9D000318  24430B00   ADDIU V1, V0, 2816
9D00031C  8FC20010   LW V0, 16(S8)
9D000320  00621021   ADDU V0, V1, V0
9D000324  90420000   LBU V0, 0(V0)
9D000328  AFC20014   SW V0, 20(S8)
92:                          //BLU
93:                          NeoBit((tmp >> 0) & 1);
9D00032C  8FC20014   LW V0, 20(S8)
9D000330  30420001   ANDI V0, V0, 1
9D000334  0F400000   JAL NeoBit
9D000338  00402021   ADDU A0, V0, ZERO
94:                          NeoBit((tmp >> 1) & 1);
9D00033C  8FC20014   LW V0, 20(S8)
9D000340  00021043   SRA V0, V0, 1
9D000344  30420001   ANDI V0, V0, 1
9D000348  0F400000   JAL NeoBit
9D00034C  00402021   ADDU A0, V0, ZERO
95:                          NeoBit((tmp >> 2) & 1);
9D000350  8FC20014   LW V0, 20(S8)
9D000354  00021083   SRA V0, V0, 2
9D000358  30420001   ANDI V0, V0, 1
9D00035C  0F400000   JAL NeoBit
9D000360  00402021   ADDU A0, V0, ZERO
96:                          NeoBit((tmp >> 3) & 1);
9D000364  8FC20014   LW V0, 20(S8)
9D000368  000210C3   SRA V0, V0, 3
9D00036C  30420001   ANDI V0, V0, 1
9D000370  0F400000   JAL NeoBit
9D000374  00402021   ADDU A0, V0, ZERO
97:                          NeoBit((tmp >> 4) & 1);
9D000378  8FC20014   LW V0, 20(S8)
9D00037C  00021103   SRA V0, V0, 4
9D000380  30420001   ANDI V0, V0, 1
9D000384  0F400000   JAL NeoBit
9D000388  00402021   ADDU A0, V0, ZERO
98:                          NeoBit((tmp >> 5) & 1);
9D00038C  8FC20014   LW V0, 20(S8)
9D000390  00021143   SRA V0, V0, 5
9D000394  30420001   ANDI V0, V0, 1
9D000398  0F400000   JAL NeoBit
9D00039C  00402021   ADDU A0, V0, ZERO
99:                          NeoBit((tmp >> 6) & 1);
9D0003A0  8FC20014   LW V0, 20(S8)
9D0003A4  00021183   SRA V0, V0, 6
9D0003A8  30420001   ANDI V0, V0, 1
9D0003AC  0F400000   JAL NeoBit
9D0003B0  00402021   ADDU A0, V0, ZERO
100:                         NeoBit((tmp >> 7) & 1);
9D0003B4  8FC20014   LW V0, 20(S8)
9D0003B8  000211C3   SRA V0, V0, 7
9D0003BC  30420001   ANDI V0, V0, 1
9D0003C0  0F400000   JAL NeoBit
9D0003C4  00402021   ADDU A0, V0, ZERO
101:                 
102:                         tmp = 0;
9D0003C8  AFC00014   SW ZERO, 20(S8)
103:                         //RED
104:                         NeoBit((tmp >> 0) & 1);
9D0003CC  8FC20014   LW V0, 20(S8)
9D0003D0  30420001   ANDI V0, V0, 1
9D0003D4  0F400000   JAL NeoBit
9D0003D8  00402021   ADDU A0, V0, ZERO
105:                         NeoBit((tmp >> 1) & 1);
9D0003DC  8FC20014   LW V0, 20(S8)
9D0003E0  00021043   SRA V0, V0, 1
9D0003E4  30420001   ANDI V0, V0, 1
9D0003E8  0F400000   JAL NeoBit
9D0003EC  00402021   ADDU A0, V0, ZERO
106:                         NeoBit((tmp >> 2) & 1);
9D0003F0  8FC20014   LW V0, 20(S8)
9D0003F4  00021083   SRA V0, V0, 2
9D0003F8  30420001   ANDI V0, V0, 1
9D0003FC  0F400000   JAL NeoBit
9D000400  00402021   ADDU A0, V0, ZERO
107:                         NeoBit((tmp >> 3) & 1);
9D000404  8FC20014   LW V0, 20(S8)
9D000408  000210C3   SRA V0, V0, 3
9D00040C  30420001   ANDI V0, V0, 1
9D000410  0F400000   JAL NeoBit
9D000414  00402021   ADDU A0, V0, ZERO
108:                         NeoBit((tmp >> 4) & 1);
9D000418  8FC20014   LW V0, 20(S8)
9D00041C  00021103   SRA V0, V0, 4
9D000420  30420001   ANDI V0, V0, 1
9D000424  0F400000   JAL NeoBit
9D000428  00402021   ADDU A0, V0, ZERO
109:                         NeoBit((tmp >> 5) & 1);
9D00042C  8FC20014   LW V0, 20(S8)
9D000430  00021143   SRA V0, V0, 5
9D000434  30420001   ANDI V0, V0, 1
9D000438  0F400000   JAL NeoBit
9D00043C  00402021   ADDU A0, V0, ZERO
110:                         NeoBit((tmp >> 6) & 1);
9D000440  8FC20014   LW V0, 20(S8)
9D000444  00021183   SRA V0, V0, 6
9D000448  30420001   ANDI V0, V0, 1
9D00044C  0F400000   JAL NeoBit
9D000450  00402021   ADDU A0, V0, ZERO
111:                         NeoBit((tmp >> 7) & 1);
9D000454  8FC20014   LW V0, 20(S8)
9D000458  000211C3   SRA V0, V0, 7
9D00045C  30420001   ANDI V0, V0, 1
9D000460  0F400000   JAL NeoBit
9D000464  00402021   ADDU A0, V0, ZERO
112:                 
113:                         //GRN
114:                         NeoBit((tmp >> 0) & 1);
9D000468  8FC20014   LW V0, 20(S8)
9D00046C  30420001   ANDI V0, V0, 1
9D000470  0F400000   JAL NeoBit
9D000474  00402021   ADDU A0, V0, ZERO
115:                         NeoBit((tmp >> 1) & 1);
9D000478  8FC20014   LW V0, 20(S8)
9D00047C  00021043   SRA V0, V0, 1
9D000480  30420001   ANDI V0, V0, 1
9D000484  0F400000   JAL NeoBit
9D000488  00402021   ADDU A0, V0, ZERO
116:                         NeoBit((tmp >> 2) & 1);
9D00048C  8FC20014   LW V0, 20(S8)
9D000490  00021083   SRA V0, V0, 2
9D000494  30420001   ANDI V0, V0, 1
9D000498  0F400000   JAL NeoBit
9D00049C  00402021   ADDU A0, V0, ZERO
117:                         NeoBit((tmp >> 3) & 1);
9D0004A0  8FC20014   LW V0, 20(S8)
9D0004A4  000210C3   SRA V0, V0, 3
9D0004A8  30420001   ANDI V0, V0, 1
9D0004AC  0F400000   JAL NeoBit
9D0004B0  00402021   ADDU A0, V0, ZERO
118:                         NeoBit((tmp >> 4) & 1);
9D0004B4  8FC20014   LW V0, 20(S8)
9D0004B8  00021103   SRA V0, V0, 4
9D0004BC  30420001   ANDI V0, V0, 1
9D0004C0  0F400000   JAL NeoBit
9D0004C4  00402021   ADDU A0, V0, ZERO
119:                         NeoBit((tmp >> 5) & 1);
9D0004C8  8FC20014   LW V0, 20(S8)
9D0004CC  00021143   SRA V0, V0, 5
9D0004D0  30420001   ANDI V0, V0, 1
9D0004D4  0F400000   JAL NeoBit
9D0004D8  00402021   ADDU A0, V0, ZERO
120:                         NeoBit((tmp >> 6) & 1);
9D0004DC  8FC20014   LW V0, 20(S8)
9D0004E0  00021183   SRA V0, V0, 6
9D0004E4  30420001   ANDI V0, V0, 1
9D0004E8  0F400000   JAL NeoBit
9D0004EC  00402021   ADDU A0, V0, ZERO
121:                         NeoBit((tmp >> 7) & 1);
9D0004F0  8FC20014   LW V0, 20(S8)
9D0004F4  000211C3   SRA V0, V0, 7
9D0004F8  30420001   ANDI V0, V0, 1
9D0004FC  0F400000   JAL NeoBit
9D000500  00402021   ADDU A0, V0, ZERO
122:                 
123:                     }
124:                 
125:                 
126:                 
127:                 }
9D000520  03C0E821   ADDU SP, S8, ZERO
9D000524  8FBF001C   LW RA, 28(SP)
9D000528  8FBE0018   LW S8, 24(SP)
9D00052C  03E00008   JR RA
9D000530  27BD0020   ADDIU SP, SP, 32
128:                 
129:                 void InitUart1() {
9D000534  27BDFFF8   ADDIU SP, SP, -8
9D000538  AFBE0004   SW S8, 4(SP)
9D00053C  03A0F021   ADDU S8, SP, ZERO
130:                 
131:                     TRIS_TX1 = 0;
9D000540  3C03BF88   LUI V1, -16504
9D000544  8C626110   LW V0, 24848(V1)
9D000548  7C0218C4   INS V0, ZERO, 3, 1
9D00054C  AC626110   SW V0, 24848(V1)
132:                     TRIS_RX1 = 1;
9D000550  3C03BF88   LUI V1, -16504
9D000554  8C626110   LW V0, 24848(V1)
9D000558  24040001   ADDIU A0, ZERO, 1
9D00055C  7C821084   INS V0, A0, 2, 1
9D000560  AC626110   SW V0, 24848(V1)
133:                 
134:                     // Create a UART TX/RX Pin
135:                     SYSKEY = 0xAA996655; // Write Key1 to SYSKEY
9D000564  3C02BF81   LUI V0, -16511
9D000568  3C03AA99   LUI V1, -21863
9D00056C  34636655   ORI V1, V1, 26197
9D000570  AC43F230   SW V1, -3536(V0)
136:                     SYSKEY = 0x556699AA; // Write Key2 to SYSKEY
9D000574  3C02BF81   LUI V0, -16511
9D000578  3C035566   LUI V1, 21862
9D00057C  346399AA   ORI V1, V1, -26198
9D000580  AC43F230   SW V1, -3536(V0)
137:                 
138:                     U1RXRbits.U1RXR = 0b0100; //U1RX -- RB2
9D000584  3C03BF81   LUI V1, -16511
9D000588  8C62FA50   LW V0, -1456(V1)
9D00058C  24040004   ADDIU A0, ZERO, 4
9D000590  7C821804   INS V0, A0, 0, 4
9D000594  AC62FA50   SW V0, -1456(V1)
139:                     RPB3Rbits.RPB3R = 0b0001; // U1TX -- RB3
9D000598  3C03BF81   LUI V1, -16511
9D00059C  8C62FB38   LW V0, -1224(V1)
9D0005A0  24040001   ADDIU A0, ZERO, 1
9D0005A4  7C821804   INS V0, A0, 0, 4
9D0005A8  AC62FB38   SW V0, -1224(V1)
140:                 
141:                     SYSKEY = 0; // Locks the pin Configurations
9D0005AC  3C02BF81   LUI V0, -16511
9D0005B0  AC40F230   SW ZERO, -3536(V0)
142:                 
143:                     U1MODE = 0;
9D0005B4  3C02BF80   LUI V0, -16512
9D0005B8  AC406000   SW ZERO, 24576(V0)
144:                     U1STA = 0;
9D0005BC  3C02BF80   LUI V0, -16512
9D0005C0  AC406010   SW ZERO, 24592(V0)
145:                 
146:                     U1MODEbits.BRGH = 0; //16xbaud
9D0005C4  3C03BF80   LUI V1, -16512
9D0005C8  8C626000   LW V0, 24576(V1)
9D0005CC  7C0218C4   INS V0, ZERO, 3, 1
9D0005D0  AC626000   SW V0, 24576(V1)
147:                     U1BRG = (FCY / (16 * 9600)) - 1;
9D0005D4  3C02BF80   LUI V0, -16512
9D0005D8  2403019F   ADDIU V1, ZERO, 415
9D0005DC  AC436040   SW V1, 24640(V0)
148:                 
149:                     U1MODEbits.RTSMD = 1; //No flow control
9D0005E0  3C03BF80   LUI V1, -16512
9D0005E4  8C626000   LW V0, 24576(V1)
9D0005E8  24040001   ADDIU A0, ZERO, 1
9D0005EC  7C825AC4   INS V0, A0, 11, 1
9D0005F0  AC626000   SW V0, 24576(V1)
150:                 
151:                     U1MODEbits.PDSEL = 0; //8bit noParuty
9D0005F4  3C03BF80   LUI V1, -16512
9D0005F8  8C626000   LW V0, 24576(V1)
9D0005FC  7C021044   INS V0, ZERO, 1, 2
9D000600  AC626000   SW V0, 24576(V1)
152:                     U1MODEbits.STSEL = 0; //Stpbit 1
9D000604  3C03BF80   LUI V1, -16512
9D000608  8C626000   LW V0, 24576(V1)
9D00060C  7C020004   INS V0, ZERO, 0, 1
9D000610  AC626000   SW V0, 24576(V1)
153:                 
154:                     U1STAbits.UTXEN = 0; //Tx disnable
9D000614  3C03BF80   LUI V1, -16512
9D000618  8C626010   LW V0, 24592(V1)
9D00061C  7C025284   INS V0, ZERO, 10, 1
9D000620  AC626010   SW V0, 24592(V1)
155:                     U1STAbits.URXEN = 1; //Rx enable
9D000624  3C03BF80   LUI V1, -16512
9D000628  8C626010   LW V0, 24592(V1)
9D00062C  24040001   ADDIU A0, ZERO, 1
9D000630  7C826304   INS V0, A0, 12, 1
9D000634  AC626010   SW V0, 24592(V1)
156:                 
157:                     U1MODEbits.UEN = 0; //NO CTS  & NO RTS
9D000638  3C03BF80   LUI V1, -16512
9D00063C  8C626000   LW V0, 24576(V1)
9D000640  7C024A04   INS V0, ZERO, 8, 2
9D000644  AC626000   SW V0, 24576(V1)
158:                     U1MODEbits.ON = 1;
9D000648  3C03BF80   LUI V1, -16512
9D00064C  8C626000   LW V0, 24576(V1)
9D000650  24040001   ADDIU A0, ZERO, 1
9D000654  7C827BC4   INS V0, A0, 15, 1
9D000658  AC626000   SW V0, 24576(V1)
159:                 
160:                     IFS1bits.U1RXIF = 0;
9D00065C  3C03BF88   LUI V1, -16504
9D000660  8C621040   LW V0, 4160(V1)
9D000664  7C024204   INS V0, ZERO, 8, 1
9D000668  AC621040   SW V0, 4160(V1)
161:                     IEC1bits.U1RXIE = 1;
9D00066C  3C03BF88   LUI V1, -16504
9D000670  8C621070   LW V0, 4208(V1)
9D000674  24040001   ADDIU A0, ZERO, 1
9D000678  7C824204   INS V0, A0, 8, 1
9D00067C  AC621070   SW V0, 4208(V1)
162:                 
163:                     IPC8bits.U1IP = 1; //Interrupts Priority
9D000680  3C03BF88   LUI V1, -16504
9D000684  8C621110   LW V0, 4368(V1)
9D000688  24040001   ADDIU A0, ZERO, 1
9D00068C  7C822084   INS V0, A0, 2, 3
9D000690  AC621110   SW V0, 4368(V1)
164:                 
165:                 }
9D000694  03C0E821   ADDU SP, S8, ZERO
9D000698  8FBE0004   LW S8, 4(SP)
9D00069C  27BD0008   ADDIU SP, SP, 8
9D0006A0  03E00008   JR RA
9D0006A4  00000000   NOP
166:                 
167:                 
168:                 unsigned int dataPos;
169:                 unsigned char myData[10];
170:                 unsigned char lastData;
171:                 
172:                 void __ISR(_UART_1_VECTOR, IPL1) U1RXHandler(void) {
9D0006A8  415DE800   RDPGPR SP, SP
9D0006AC  401A7000   MFC0 K0, EPC
9D0006B0  401B6000   MFC0 K1, Status
9D0006B4  27BDFFE0   ADDIU SP, SP, -32
9D0006B8  AFBA001C   SW K0, 28(SP)
9D0006BC  AFBB0018   SW K1, 24(SP)
9D0006C0  7C1B7844   INS K1, ZERO, 1, 15
9D0006C4  377B0400   ORI K1, K1, 1024
9D0006C8  409B6000   MTC0 K1, Status
9D0006CC  AFBE0014   SW S8, 20(SP)
9D0006D0  AFA30010   SW V1, 16(SP)
9D0006D4  AFA2000C   SW V0, 12(SP)
9D0006D8  03A0F021   ADDU S8, SP, ZERO
173:                     unsigned char RcvData;
174:                 
175:                     IFS1bits.U1RXIF = 0;
9D0006DC  3C03BF88   LUI V1, -16504
9D0006E0  8C621040   LW V0, 4160(V1)
9D0006E4  7C024204   INS V0, ZERO, 8, 1
9D0006E8  AC621040   SW V0, 4160(V1)
176:                 
177:                     RcvData = getcUART1();
9D0006EC  3C02BF80   LUI V0, -16512
9D0006F0  8C426030   LW V0, 24624(V0)
9D0006F4  A3C20000   SB V0, 0(S8)
178:                 
179:                     if (RcvData == 255) {
9D0006F8  93C30000   LBU V1, 0(S8)
9D0006FC  240200FF   ADDIU V0, ZERO, 255
9D000700  14620004   BNE V1, V0, 0x9D000714
9D000704  00000000   NOP
180:                         dataPos = 0;
9D000708  AF808014   SW ZERO, -32748(GP)
9D00070C  0B40021C   J 0x9D000870
9D000710  00000000   NOP
181:                     } else {
182:                         if (RcvData == 'X' || RcvData == 'G' || RcvData == 'O' || RcvData == 'P'
9D000714  93C30000   LBU V1, 0(S8)
9D000718  24020058   ADDIU V0, ZERO, 88
9D00071C  1062003D   BEQ V1, V0, 0x9D000814
9D000720  00000000   NOP
9D000724  93C30000   LBU V1, 0(S8)
9D000728  24020047   ADDIU V0, ZERO, 71
9D00072C  10620039   BEQ V1, V0, 0x9D000814
9D000730  00000000   NOP
9D000734  93C30000   LBU V1, 0(S8)
9D000738  2402004F   ADDIU V0, ZERO, 79
9D00073C  10620035   BEQ V1, V0, 0x9D000814
9D000740  00000000   NOP
9D000744  93C30000   LBU V1, 0(S8)
9D000748  24020050   ADDIU V0, ZERO, 80
9D00074C  10620031   BEQ V1, V0, 0x9D000814
9D000750  00000000   NOP
183:                 
184:                                 || RcvData == 'U' || RcvData == 'D'
9D000754  93C30000   LBU V1, 0(S8)
9D000758  24020055   ADDIU V0, ZERO, 85
9D00075C  1062002D   BEQ V1, V0, 0x9D000814
9D000760  00000000   NOP
9D000764  93C30000   LBU V1, 0(S8)
9D000768  24020044   ADDIU V0, ZERO, 68
9D00076C  10620029   BEQ V1, V0, 0x9D000814
9D000770  00000000   NOP
185:                                 || RcvData == 'L' || RcvData == 'R'
9D000774  93C30000   LBU V1, 0(S8)
9D000778  2402004C   ADDIU V0, ZERO, 76
9D00077C  10620025   BEQ V1, V0, 0x9D000814
9D000780  00000000   NOP
9D000784  93C30000   LBU V1, 0(S8)
9D000788  24020052   ADDIU V0, ZERO, 82
9D00078C  10620021   BEQ V1, V0, 0x9D000814
9D000790  00000000   NOP
186:                 
187:                                 || RcvData == 'g' //STK-L LEFT
9D000794  93C30000   LBU V1, 0(S8)
9D000798  24020067   ADDIU V0, ZERO, 103
9D00079C  1062001D   BEQ V1, V0, 0x9D000814
9D0007A0  00000000   NOP
188:                                 || RcvData == 'h' //STK-L RIGHT
9D0007A4  93C30000   LBU V1, 0(S8)
9D0007A8  24020068   ADDIU V0, ZERO, 104
9D0007AC  10620019   BEQ V1, V0, 0x9D000814
9D0007B0  00000000   NOP
189:                                 || RcvData == 'i' //STK-L UP
9D0007B4  93C30000   LBU V1, 0(S8)
9D0007B8  24020069   ADDIU V0, ZERO, 105
9D0007BC  10620015   BEQ V1, V0, 0x9D000814
9D0007C0  00000000   NOP
190:                                 || RcvData == 'j'
9D0007C4  93C30000   LBU V1, 0(S8)
9D0007C8  2402006A   ADDIU V0, ZERO, 106
9D0007CC  10620011   BEQ V1, V0, 0x9D000814
9D0007D0  00000000   NOP
191:                 
192:                                 || RcvData == 'k' //STK-R LEFT
9D0007D4  93C30000   LBU V1, 0(S8)
9D0007D8  2402006B   ADDIU V0, ZERO, 107
9D0007DC  1062000D   BEQ V1, V0, 0x9D000814
9D0007E0  00000000   NOP
193:                                 || RcvData == 'l' //STK-R RIGHT
9D0007E4  93C30000   LBU V1, 0(S8)
9D0007E8  2402006C   ADDIU V0, ZERO, 108
9D0007EC  10620009   BEQ V1, V0, 0x9D000814
9D0007F0  00000000   NOP
194:                                 || RcvData == 'm' //STK-R UP
9D0007F4  93C30000   LBU V1, 0(S8)
9D0007F8  2402006D   ADDIU V0, ZERO, 109
9D0007FC  10620005   BEQ V1, V0, 0x9D000814
9D000800  00000000   NOP
195:                                 || RcvData == 'n' //STK-R DOWN
9D000804  93C30000   LBU V1, 0(S8)
9D000808  2402006E   ADDIU V0, ZERO, 110
9D00080C  14620018   BNE V1, V0, 0x9D000870
9D000810  00000000   NOP
196:                                 ) {
197:                             myData[dataPos] = RcvData;
9D000814  8F838014   LW V1, -32748(GP)
9D000818  3C02A000   LUI V0, -24576
9D00081C  2442031C   ADDIU V0, V0, 796
9D000820  00621021   ADDU V0, V1, V0
9D000824  93C30000   LBU V1, 0(S8)
9D000828  A0430000   SB V1, 0(V0)
198:                             if (RcvData == 'k' || RcvData == 'D') {
9D00082C  93C30000   LBU V1, 0(S8)
9D000830  2402006B   ADDIU V0, ZERO, 107
9D000834  10620005   BEQ V1, V0, 0x9D00084C
9D000838  00000000   NOP
9D00083C  93C30000   LBU V1, 0(S8)
9D000840  24020044   ADDIU V0, ZERO, 68
9D000844  14620002   BNE V1, V0, 0x9D000850
9D000848  00000000   NOP
199:                 
200:                                 firstReset = 0;
9D00084C  AF808028   SW ZERO, -32728(GP)
201:                             } else {
202:                                 if (myData[0] != lastData) {
203:                 //                    resetAnimation();
204:                                 }
205:                             }
206:                             dataPos++;
9D000850  8F828014   LW V0, -32748(GP)
9D000854  24420001   ADDIU V0, V0, 1
9D000858  AF828014   SW V0, -32748(GP)
207:                             if (dataPos >= 10)dataPos = 0;
9D00085C  8F828014   LW V0, -32748(GP)
9D000860  2C42000A   SLTIU V0, V0, 10
9D000864  14400002   BNE V0, ZERO, 0x9D000870
9D000868  00000000   NOP
9D00086C  AF808014   SW ZERO, -32748(GP)
208:                         }
209:                     }
210:                     lastData = myData[0];
9D000870  3C02A000   LUI V0, -24576
9D000874  9042031C   LBU V0, 796(V0)
9D000878  A3828010   SB V0, -32752(GP)
211:                 }
9D00087C  03C0E821   ADDU SP, S8, ZERO
9D000880  8FBE0014   LW S8, 20(SP)
9D000884  8FA30010   LW V1, 16(SP)
9D000888  8FA2000C   LW V0, 12(SP)
9D00088C  41606000   DI ZERO
9D000890  000000C0   EHB
9D000894  8FBA001C   LW K0, 28(SP)
9D000898  8FBB0018   LW K1, 24(SP)
9D00089C  409A7000   MTC0 K0, EPC
9D0008A0  27BD0020   ADDIU SP, SP, 32
9D0008A4  41DDE800   WRPGPR SP, SP
9D0008A8  409B6000   MTC0 K1, Status
9D0008AC  42000018   ERET
212:                 
213:                 int main(void) {
9D0008B0  27BDFFA8   ADDIU SP, SP, -88
9D0008B4  AFBF0054   SW RA, 84(SP)
9D0008B8  AFBE0050   SW S8, 80(SP)
9D0008BC  03A0F021   ADDU S8, SP, ZERO
9D0008C0  3C0203D0   LUI V0, 976
9D0008C4  34429000   ORI V0, V0, -28672
9D0008C8  AFC20014   SW V0, 20(S8)
9D0008CC  8FC20014   LW V0, 20(S8)
9D0008D0  AFC20018   SW V0, 24(S8)
9D0008D4  8FC20018   LW V0, 24(S8)
9D0008D8  AFC2001C   SW V0, 28(S8)
214:                     int i;
215:                     int j;
216:                 
217:                     SYSTEMConfigPerformance(SYSCLK);
218:                 //    INTEnableSystemMultiVectoredInt();
219:                 //    INTEnableInterrupts();
220:                 
221:                     ANSELA = 0x0000; // all digital pins
9D000A98  3C02BF88   LUI V0, -16504
9D000A9C  AC406000   SW ZERO, 24576(V0)
222:                     ANSELB = 0x0000;
9D000AA0  3C02BF88   LUI V0, -16504
9D000AA4  AC406100   SW ZERO, 24832(V0)
223:                 
224:                     TRISB = 0;
9D000AA8  3C02BF88   LUI V0, -16504
9D000AAC  AC406110   SW ZERO, 24848(V0)
225:                     TRISA = 0;
9D000AB0  3C02BF88   LUI V0, -16504
9D000AB4  AC406010   SW ZERO, 24592(V0)
226:                 
227:                 //    InitUart1();
228:                 
229:                     neopixel_pin=0;
9D000AB8  3C03BF88   LUI V1, -16504
9D000ABC  8C626130   LW V0, 24880(V1)
9D000AC0  7C024A44   INS V0, ZERO, 9, 1
9D000AC4  AC626130   SW V0, 24880(V1)
230:                     for(i=0; i<1000; i++){
9D000AC8  0B4002B8   J 0x9D000AE0
9D000ACC  AFC00010   SW ZERO, 16(S8)
9D000AD4  8FC20010   LW V0, 16(S8)
9D000AD8  24420001   ADDIU V0, V0, 1
9D000ADC  AFC20010   SW V0, 16(S8)
9D000AE0  8FC20010   LW V0, 16(S8)
9D000AE4  284203E8   SLTI V0, V0, 1000
9D000AE8  1440FFF9   BNE V0, ZERO, 0x9D000AD0
9D000AEC  00000000   NOP
231:                         Nop();
9D000AD0  00000040   SSNOP
232:                     }
233:                 //    resetAnimation();
234:                     //    myData[0] = 'k';
235:                     while (1) {
236:                 
237:                         Neopixel();
9D000AF0  0F4000B1   JAL Neopixel
9D000AF4  00000000   NOP
238:                         //        
239:                         //        switch (myData[0]) {
240:                         //            default:
241:                         ////                myData[0] = 0;
242:                         ////                resetAnimation();
243:                         //                break;
244:                         //
245:                         //                //UP
246:                         //            case 'U':
247:                         //                break;
248:                         //
249:                         //                //DOWN
250:                         //            case 'D':
251:                         //                break;
252:                         //
253:                         //
254:                         //                //LEFT
255:                         //                //NORMAL BLINK
256:                         //            case 'L':
257:                         //
258:                         //                break;
259:                         //
260:                         //                //RIGHT 
261:                         //                //BROKEN BLINK
262:                         //            case 'R':
263:                         //
264:                         //                break;
265:                         //
266:                         //
267:                         //                //BATSU
268:                         //                //DELETE
269:                         //            case 'X':
270:                         //                for (i = 0; i < 256; i++) {
271:                         //                    r[i] = 0;
272:                         //                    g[i] = 0;
273:                         //                    b[i] = 0;
274:                         //                }
275:                         //                break;
276:                         //
277:                         //                //SANKAKU
278:                         //                //BATSU
279:                         //            case 'G':
280:                         //
281:                         //                break;
282:                         //
283:                         //                //MARU
284:                         //                //HATENA?
285:                         //            case 'O':
286:                         //
287:                         //                break;
288:                         //
289:                         //                //SIKAKU
290:                         //                //BREAK HEART
291:                         //            case 'P':
292:                         //
293:                         //                break;
294:                         //
295:                         //                //STK-L LEFT
296:                         //                //WAVE
297:                         //            case 'g':
298:                         //
299:                         //                break;
300:                         //                //STK-L RIGHT
301:                         //                //ENERGY
302:                         //            case 'h':
303:                         //
304:                         //                break;
305:                         //
306:                         //                //STK-L UP
307:                         //                //START UP
308:                         //            case 'i':
309:                         //
310:                         //                break;
311:                         //
312:                         //                //STK-L DOWN
313:                         //            case 'j':
314:                         //
315:                         //                break;
316:                         //
317:                         //                //STK-R LEFT
318:                         //                //RAIBOW - LEFT
319:                         //            case 'k':
320:                         //
321:                         //                break;
322:                         //
323:                         //                //STK-R RIGHT
324:                         //                //RAIBOW - RIGHT
325:                         //            case 'l':
326:                         //
327:                         //                break;
328:                         //
329:                         //                //STK-R UP
330:                         //            case 'm':
331:                         //
332:                         //                break;
333:                         //
334:                         //                //STK-R DOWN
335:                         //            case 'n':
336:                         //
337:                         //                break;
338:                         //        }
339:                 
340:                     }
9D000AF8  0B4002BC   J 0x9D000AF0
9D000AFC  00000000   NOP
9D000B00  30300000   ANDI S0, AT, 0
341:                 
342:                 }
343:                 
344:                 //void resetAnimation() {
345:                 //    int i;
346:                 //    for (i = 0; i < 256; i++) {
347:                 //        r[i] = 0;
348:                 //        g[i] = 0;
349:                 //        b[i] = 0;
350:                 //    }
351:                 //    firstReset = 0;
352:                 //}
---  /Applications/microchip/xc32/v1.31/pic32mx/include/peripheral/system.h  ----------------------------
1:                   /********************************************************************
2:                   
3:                   	System Library Interface Definition
4:                   	
5:                   	Summary:
6:                   		This file contains the interface definition for the System
7:                   		peripheral library.
8:                   		
9:                   	Description:
10:                  		This library provides functions for configuring the peripheral
11:                  		clock, cache settings, and wait states.  For details on the
12:                  		register and bit settings used by these functions, refer to the
13:                  		PIC32 Family Reference Manual.
14:                  
15:                  
16:                   ********************************************************************/
17:                  //DOM-IGNORE-BEGIN
18:                  /********************************************************************
19:                   * FileName:		System.h
20:                   * Dependencies:
21:                   * Processor:		PIC32
22:                   * Hardware:		N/A
23:                   * Assembler:		N/A
24:                   * Linker:		    N/A
25:                   * Company:		    Microchip Technology Inc.
26:                   *
27:                   * Software License Agreement:
28:                   * The software supplied herewith by Microchip Technology Incorporated
29:                   * (the �Company�) for its PICmicro� Microcontroller is intended and
30:                   * supplied to you, the Company�s customer, for use solely and
31:                   * exclusively on Microchip PICmicro Microcontroller products. The
32:                   * software is owned by the Company and/or its supplier, and is
33:                   * protected under applicable copyright laws. All rights are reserved.
34:                   * Any use in violation of the foregoing restrictions may subject the
35:                   * user to criminal sanctions under applicable laws, as well as to
36:                   * civil liability for the breach of the terms and conditions of this
37:                   * license.
38:                   *
39:                   * THIS SOFTWARE IS PROVIDED IN AN �AS IS� CONDITION. NO WARRANTIES,
40:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
41:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
42:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
43:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
44:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
45:                   *
46:                   * $Id: CoreTimer.h,v 1.2 2006/11/03 15:07:21 C12923 Exp $
47:                   * $Name:  $
48:                   ********************************************************************/
49:                  //DOM-IGNORE-END
50:                   
51:                   
52:                  #ifndef _SYSTEM_HEADER_FILE
53:                  #define _SYSTEM_HEADER_FILE
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/int.h>
57:                  #include <peripheral/pcache.h>
58:                  #include <peripheral/osc.h>
59:                  #include <peripheral/dma.h>
60:                  #include <peripheral/bmx.h>
61:                  #include <peripheral/lock.h>
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  #define FLASH_SPEED_HZ          30000000 //Max Flash speed
67:                  #define PB_BUS_MAX_FREQ_HZ      80000000 //Max Peripheral bus speed
68:                  
69:                  /*********************************************************************
70:                   * SYSTEMConfig Flags
71:                   *********************************************************************/
72:                  #define SYS_CFG_WAIT_STATES     0x00000001 //SYSTEMConfig wait states
73:                  #define SYS_CFG_PB_BUS          0x00000002 //SYSTEMConfig pb bus
74:                  #define SYS_CFG_PCACHE          0x00000004 //SYSTEMConfig cache
75:                  #define SYS_CFG_ALL             0xFFFFFFFF //SYSTEMConfig All
76:                  
77:                  /*********************************************************************
78:                   Function:       
79:                  	unsigned int SYSTEMConfigPB(unsigned int sys_clock)
80:                   
81:                   Description:
82:                  	The function sets the PB divider to the optimum value.
83:                   
84:                   PreCondition:    
85:                  	None
86:                   
87:                   Parameters:           
88:                  	sys_clock - system clock in Hz
89:                   
90:                   Returns:          
91:                  	the PB clock frequency in Hz
92:                   
93:                   Side Effects:
94:                  	The PB clock may be changed
95:                  	
96:                   Overview:	    
97:                  	The function sets the PB divider to the optimum value.
98:                   
99:                   Remarks:            
100:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
101:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
102:                  
103:                  Example:
104:                 	<code>
105:                 	SYSTEMConfigPB(72000000);
106:                 	</code>
107:                  ********************************************************************/
108:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPB(unsigned int sys_clock)
109:                 {
110:                     unsigned int pb_div;
111:                     unsigned int pb_clock;
112:                 
113:                     pb_clock = sys_clock;
9D0008DC  8FC2001C   LW V0, 28(S8)
9D0008E0  AFC20020   SW V0, 32(S8)
114:                 
115:                     if(sys_clock > PB_BUS_MAX_FREQ_HZ)
9D0008E4  8FC3001C   LW V1, 28(S8)
9D0008E8  3C0204C4   LUI V0, 1220
9D0008EC  3442B401   ORI V0, V0, -19455
9D0008F0  0062102B   SLTU V0, V1, V0
9D0008F4  14400007   BNE V0, ZERO, 0x9D000914
9D0008F8  00000000   NOP
116:                     {
117:                         pb_div=OSC_PB_DIV_2;
9D0008FC  3C020008   LUI V0, 8
9D000900  AFC20024   SW V0, 36(S8)
118:                         pb_clock >>= 1;
9D000904  8FC20020   LW V0, 32(S8)
9D000908  00021042   SRL V0, V0, 1
9D00090C  0B400246   J 0x9D000918
9D000910  AFC20020   SW V0, 32(S8)
119:                     }
120:                     else
121:                     {
122:                         pb_div=OSC_PB_DIV_1;
9D000914  AFC00024   SW ZERO, 36(S8)
9D000918  8FC20024   LW V0, 36(S8)
9D00091C  AFC20028   SW V0, 40(S8)
123:                     }
124:                 
125:                     OSCSetPBDIV(pb_div);
126:                 
127:                     return pb_clock;
9D000A68  8FC20020   LW V0, 32(S8)
128:                 }
129:                 
130:                 
131:                 /*********************************************************************
132:                   Function:        
133:                 	void SYSTEMConfigWaitStates(unsigned int sys_clock)
134:                  
135:                   Description:
136:                 	The function sets the Flash Wait states to the optimum value.
137:                  
138:                   PreCondition:    
139:                 	None
140:                  
141:                   Parameters:           
142:                 	sys_clock - system clock in Hz
143:                  
144:                   Returns:          
145:                 	None
146:                  
147:                   Side Effects:    
148:                 	The Wait States may be changed  
149:                  
150:                   Remarks:         
151:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
152:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
153:                  
154:                   Example:
155:                 	<code>
156:                 	SYSTEMConfigWaitStates(72000000);
157:                 	</code>
158:                  ********************************************************************/
159:                 extern inline void __attribute__((always_inline)) SYSTEMConfigWaitStates(unsigned int sys_clock)
160:                 {
161:                 #ifdef _PCACHE
162:                     unsigned int wait_states;
163:                     unsigned int int_status;
164:                 #endif
165:                 
166:                 #ifdef _PCACHE
167:                     wait_states = 0;
168:                 
169:                     while(sys_clock > FLASH_SPEED_HZ)
170:                     {
171:                         wait_states++;
172:                         sys_clock -= FLASH_SPEED_HZ;
173:                     }
174:                 
175:                     int_status=INTDisableInterrupts();
176:                     mCheConfigure(wait_states);
177:                     INTRestoreInterrupts(int_status);
178:                 
179:                 #endif
180:                 }
181:                 
182:                 /*********************************************************************
183:                   Function:        
184:                 		unsigned int SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
185:                   
186:                   Description:
187:                 	The function sets the PB divider and the Flash Wait states to the optimum value.
188:                  
189:                   PreCondition:    
190:                 	None
191:                  
192:                   Parameters:           
193:                 	sys_clock - system clock in Hz
194:                  
195:                   Returns:          
196:                 	the PB clock frequency in Hz
197:                  
198:                   Side Effects:    
199:                 	The PB clock and wait states may be changed
200:                 
201:                   Remarks:            
202:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
203:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
204:                  
205:                   Example:
206:                 	<code>
207:                 	SYSTEMConfigWaitStatesAndPB(72000000);
208:                 	</code>
209:                  ********************************************************************/
210:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
211:                 {
212:                 #ifdef _PCACHE
213:                     unsigned int wait_states;
214:                 #endif
215:                     unsigned int pb_clock;
216:                     unsigned int int_status;
217:                 
218:                     pb_clock = SYSTEMConfigPB(sys_clock);
9D000A6C  AFC20040   SW V0, 64(S8)
219:                 
220:                 
221:                     // set the flash wait states based on 1 wait state
222:                     // for every 20 MHz
223:                 #ifdef _PCACHE
224:                     wait_states = 0;
225:                 
226:                     while(sys_clock > FLASH_SPEED_HZ)
227:                     {
228:                         wait_states++;
229:                         sys_clock -= FLASH_SPEED_HZ;
230:                     }
231:                 
232:                     int_status=INTDisableInterrupts();
233:                     mCheConfigure(wait_states);
234:                     INTRestoreInterrupts(int_status);
235:                 
236:                 #endif
237:                 
238:                     return pb_clock;
9D000A70  8FC20040   LW V0, 64(S8)
239:                 }
240:                 /*********************************************************************
241:                   Function:       
242:                 	unsigned int SYSTEMConfigPerformance(unsigned int sys_clock)
243:                  
244:                   Description:
245:                 	The function sets the PB divider, the Flash Wait states and the DRM wait states to the optimum value.
246:                     It also enables the cacheability for the K0 segment.
247:                 	
248:                   PreCondition:    
249:                 	None
250:                  
251:                   Parameters:           
252:                 	sys_clock - system clock in Hz
253:                  
254:                   Output:          
255:                 	the PB clock frequency in Hz
256:                  
257:                   Side Effects:    
258:                 	Sets the PB and Flash Wait states
259:                  	
260:                   Remarks:            
261:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
262:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
263:                  
264:                   Example:
265:                 	<code>
266:                 	SYSTEMConfigPerformance(72000000);
267:                 	</code>
268:                  ********************************************************************/
269:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPerformance(unsigned int sys_clock)
270:                 {
271:                     // set up the wait states
272:                     unsigned int pb_clk;
273:                 #ifdef _PCACHE
274:                     unsigned int cache_status;
275:                 #endif
276:                     unsigned int int_status;
277:                 
278:                     pb_clk = SYSTEMConfigWaitStatesAndPB(sys_clock);
9D000A74  AFC20044   SW V0, 68(S8)
279:                 
280:                     int_status=INTDisableInterrupts();
9D000A78  0F400514   JAL INTDisableInterrupts
9D000A7C  00000000   NOP
9D000A80  AFC20048   SW V0, 72(S8)
281:                 
282:                     mBMXDisableDRMWaitState();
9D000A84  3C02BF88   LUI V0, -16504
9D000A88  24030040   ADDIU V1, ZERO, 64
9D000A8C  AC432004   SW V1, 8196(V0)
283:                 
284:                 #ifdef _PCACHE
285:                     cache_status = mCheGetCon();
286:                     cache_status |= CHE_CONF_PF_ALL;
287:                     mCheConfigure(cache_status);
288:                     CheKseg0CacheOn();
289:                 #endif
290:                 
291:                     INTRestoreInterrupts(int_status);
9D000A90  0F400503   JAL INTRestoreInterrupts
9D000A94  8FC40048   LW A0, 72(S8)
292:                 
293:                     return pb_clk;
294:                 
295:                 }
296:                 /*********************************************************************
297:                   Function:       
298:                 	unsigned int SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
299:                  
300:                   Description:
301:                 	The function sets the PB divider, the Flash Wait states or the DRM wait states to the optimum value, 
302:                 	based on the flags selected and on the frequency of the system clock.
303:                     It also enables the cacheability for the K0 segment.
304:                 				   
305:                   PreCondition:    
306:                 	None
307:                  
308:                   Parameters:           
309:                 	sys_clock - system clock frequency in Hz
310:                     flags -
311:                 		*    SYS_CFG_WAIT_STATES  - configure the flash wait states from the system clock
312:                         *    SYS_CFG_PB_BUS       - configure the PB bus from the system clock
313:                         *    SYS_CFG_PCACHE      - configure the pCache (if used)
314:                         *    SYS_CFG_ALL          - configure all based on system clock
315:                  
316:                   Returns:          
317:                 	the PB clock frequency in Hz
318:                  
319:                   Side Effects:    
320:                 	Could change the wait state, pb clock and turn on the pre-fetch buffer and cache. Sets the RAM
321:                     wait state to 0.
322:                   
323:                  
324:                   Remarks:
325:                 	The interrupts are disabled shortly, the DMA is suspended and the system is unlocked while performing the operation.
326:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
327:                  
328:                   Example:
329:                 	<code>
330:                 	SYSTEMConfig(72000000, SYS_CFG_ALL);
331:                 	</code>
332:                  ********************************************************************/
333:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
334:                 {
335:                     unsigned int pb_clk;
336:                     unsigned int int_status;
337:                 #ifdef _PCACHE
338:                     unsigned int cache_status;
339:                 #endif
340:                 
341:                     int_status=INTDisableInterrupts();
342:                 
343:                     mBMXDisableDRMWaitState();
344:                 
345:                     if(flags & SYS_CFG_WAIT_STATES)
346:                     {
347:                         SYSTEMConfigWaitStates(sys_clock);
348:                     }
349:                 
350:                     if(flags & SYS_CFG_PB_BUS)
351:                     {
352:                         SYSTEMConfigPB(sys_clock);
353:                     }
354:                 
355:                 
356:                 #ifdef _PCACHE
357:                     if(flags & SYS_CFG_PCACHE)
358:                     {
359:                         cache_status = mCheGetCon();
360:                         cache_status |= CHE_CONF_PF_ALL;
361:                         mCheConfigure(cache_status);
362:                         CheKseg0CacheOn();
363:                     }
364:                 #endif
365:                 
366:                     pb_clk = sys_clock;
367:                     pb_clk >>= OSCCONbits.PBDIV;
368:                 
369:                     INTRestoreInterrupts(int_status);
370:                 
371:                     return pb_clk;
372:                 
373:                 }
374:                 #ifdef __cplusplus
375:                   }
376:                 #endif
377:                 #endif
378:                 
---  /Applications/microchip/xc32/v1.31/pic32mx/include/peripheral/osc.h  -------------------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  OSC API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        OSC.h
7:                    * Dependencies:
8:                    * Processor:       PIC32
9:                    *
10:                   *
11:                   * Compiler:        MPLAB XC32
12:                   *                  MPLAB IDE
13:                   * Company:         Microchip Technology Inc.
14:                   *
15:                   * Software License Agreement
16:                   *
17:                   * The software supplied herewith by Microchip Technology Incorporated
18:                   * (the �Company�) for its PIC Microcontroller is intended
19:                   * and supplied to you, the Company�s customer, for use solely and
20:                   * exclusively on Microchip PIC Microcontroller products.
21:                   * The software is owned by the Company and/or its supplier, and is
22:                   * protected under applicable copyright laws. All rights are reserved.
23:                   * Any use in violation of the foregoing restrictions may subject the
24:                   * user to criminal sanctions under applicable laws, as well as to
25:                   * civil liability for the breach of the terms and conditions of this
26:                   * license.
27:                   *
28:                   * THIS SOFTWARE IS PROVIDED IN AN �AS IS� CONDITION. NO WARRANTIES,
29:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                   *
35:                   *
36:                   * $Id: OSC.h,v 1.6 2006/10/13 21:24:31 C12532 Exp $
37:                   * $Name:  $
38:                   ********************************************************************/
39:                  
40:                  #ifndef OSC_H_
41:                  #define OSC_H_
42:                  
43:                  #include <xc.h>
44:                  #include <peripheral/lock.h>
45:                  
46:                  #define _OSC_
47:                  
48:                  /*********************************************************************
49:                   * Function:        OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div)
50:                   *
51:                   * Description:	    Sets Osc options and clock source
52:                   *
53:                   * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
54:                   *
55:                   * Inputs:	    	Clock source, PLL multiplier, PLL postscaler, FRC divisor - see below
56:                   *
57:                   * Output:          None
58:                   *
59:                   * Example:	    	OSCConfig( OSC_POSC, OSC_PLL_MULT_24, OSC_PLL_POST_256, OSC_FRC_POST_64 )
60:                   *
61:                   * Note:	    	Forces cpu clock source to FRC(no divisor, no PLL), configures new clock
62:                   * 		     		source and then switches to the new clock source
63:                   *
64:                   *		    		Unused parameters are set to zero/default values.
65:                   ********************************************************************/
66:                  void OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div);
67:                  
68:                  	/******************************************************************************
69:                  	 * Available options for source parameter
70:                  	 *****************************************************************************/
71:                  		// CPU Oscillator modes - values are mutually exclusive
72:                  		#define OSC_FRC_DIV 	(7 << _OSCCON_NOSC_POSITION)
73:                  		#define OSC_FRC_DIV16 	(6 << _OSCCON_NOSC_POSITION)
74:                  		#define OSC_LPRC        (5 << _OSCCON_NOSC_POSITION)
75:                  		#define OSC_SOSC        (4 << _OSCCON_NOSC_POSITION)
76:                  		#define OSC_POSC_PLL 	(3 << _OSCCON_NOSC_POSITION)
77:                  		#define OSC_POSC        (2 << _OSCCON_NOSC_POSITION)
78:                  		#define OSC_FRC_PLL 	(1 << _OSCCON_NOSC_POSITION)
79:                  		#define OSC_FRC         (0 << _OSCCON_NOSC_POSITION)
80:                  
81:                  	/******************************************************************************
82:                  	 * Available options for mult parameter
83:                  	 *****************************************************************************/
84:                  		// CPU PLL multiplier values - values are mutually exclusive
85:                  		#define OSC_PLL_MULT_24 (7 << _OSCCON_PLLMULT_POSITION)
86:                  		#define OSC_PLL_MULT_21 (6 << _OSCCON_PLLMULT_POSITION)
87:                  		#define OSC_PLL_MULT_20 (5 << _OSCCON_PLLMULT_POSITION)
88:                  		#define OSC_PLL_MULT_19 (4 << _OSCCON_PLLMULT_POSITION)
89:                  		#define OSC_PLL_MULT_18 (3 << _OSCCON_PLLMULT_POSITION)
90:                  		#define OSC_PLL_MULT_17 (2 << _OSCCON_PLLMULT_POSITION)
91:                  		#define OSC_PLL_MULT_16 (1 << _OSCCON_PLLMULT_POSITION)
92:                  		#define OSC_PLL_MULT_15 (0 << _OSCCON_PLLMULT_POSITION)
93:                  
94:                  	/******************************************************************************
95:                  	 * Available options for post parameter
96:                  	 *****************************************************************************/
97:                  		// CPU PLL output divisor values - values are mutuallye exclusive
98:                  		#define OSC_PLL_POST_256 (7 << _OSCCON_PLLODIV_POSITION)
99:                  		#define OSC_PLL_POST_64  (6 << _OSCCON_PLLODIV_POSITION)
100:                 		#define OSC_PLL_POST_32  (5 << _OSCCON_PLLODIV_POSITION)
101:                 		#define OSC_PLL_POST_16  (4 << _OSCCON_PLLODIV_POSITION)
102:                 		#define OSC_PLL_POST_8   (3 << _OSCCON_PLLODIV_POSITION)
103:                 		#define OSC_PLL_POST_4   (2 << _OSCCON_PLLODIV_POSITION)
104:                 		#define OSC_PLL_POST_2   (1 << _OSCCON_PLLODIV_POSITION)
105:                 		#define OSC_PLL_POST_1   (0 << _OSCCON_PLLODIV_POSITION)
106:                 
107:                 	/******************************************************************************
108:                 	 * Available options for div parameter
109:                 	 *****************************************************************************/
110:                 		// CPU FRC output divisor values - values are mutually exclusive
111:                 		#define OSC_FRC_POST_256 (7 << _OSCCON_FRCDIV_POSITION)
112:                 		#define OSC_FRC_POST_64  (6 << _OSCCON_FRCDIV_POSITION)
113:                 		#define OSC_FRC_POST_32  (5 << _OSCCON_FRCDIV_POSITION)
114:                 		#define OSC_FRC_POST_16  (4 << _OSCCON_FRCDIV_POSITION)
115:                 		#define OSC_FRC_POST_8   (3 << _OSCCON_FRCDIV_POSITION)
116:                 		#define OSC_FRC_POST_4   (2 << _OSCCON_FRCDIV_POSITION)
117:                 		#define OSC_FRC_POST_2   (1 << _OSCCON_FRCDIV_POSITION)
118:                 		#define OSC_FRC_POST_1   (0 << _OSCCON_FRCDIV_POSITION)
119:                 	/***********************************
120:                 	 * End parameter values
121:                 	 ************************************/
122:                 
123:                 #if (((__PIC32_FEATURE_SET__ >= 100) && (__PIC32_FEATURE_SET__ <= 299)) || \
124:                     (__PIC32_FEATURE_SET__ == 330) || (__PIC32_FEATURE_SET__ == 350) || (__PIC32_FEATURE_SET__ == 370) || (__PIC32_FEATURE_SET__ == 430) || (__PIC32_FEATURE_SET__ == 450) || (__PIC32_FEATURE_SET__ == 470))
125:                 	
126:                 		// Reference Oscillator Source Select bits - values are mutually exclusive
127:                 	#define OSC_REFOCON_REFCLKI	 	(7 << _REFOCON_ROSEL_POSITION )
128:                 	#define OSC_REFOCON_SYSPLL 		(7 << _REFOCON_ROSEL_POSITION )
129:                 	#define OSC_REFOCON_USBPLL 		(6 << _REFOCON_ROSEL_POSITION )
130:                 	#define OSC_REFOCON_SOSC        (5 << _REFOCON_ROSEL_POSITION )
131:                 	#define OSC_REFOCON_LPRC        (4 << _REFOCON_ROSEL_POSITION )
132:                 	#define OSC_REFOCON_FRC 		(3 << _REFOCON_ROSEL_POSITION )
133:                 	#define OSC_REFOCON_POSC        (2 << _REFOCON_ROSEL_POSITION )
134:                 	#define OSC_REFOCON_PBCLK 		(1 << _REFOCON_ROSEL_POSITION )
135:                 	#define OSC_REFOCON_SYSCLK      (0 << _REFOCON_ROSEL_POSITION )
136:                 		
137:                 	typedef enum
138:                 	{		
139:                 		OSC_REFOCON_RLSPEN		=(1 << _REFOCON_RSLP_POSITION )	,
140:                 		OSC_REFOCON_OE			=(1 << _REFOCON_OE_POSITION ),
141:                 		OSC_REFOCON_SIDLEN		=(1 << _REFOCON_SIDL_POSITION ),
142:                 		OSC_REFOCON_ON			=(1 << _REFOCON_ON_POSITION )
143:                 	} OSCREFConfigFlags;
144:                 	
145:                 	void OSCREFConfig(unsigned long int source, OSCREFConfigFlags config, unsigned long int div);
146:                 	 
147:                 
148:                 	#define mOSCREFOTRIMSet(trim) 		(REFOTRIM = (trim << _REFOTRIM_ROTRIM_POSITION))
149:                 
150:                 #endif
151:                 
152:                 	 
153:                 	 
154:                 	 
155:                 /*********************************************************************
156:                  * Function:    OSCSetPBDIV(unsigned int oscPbDiv)
157:                  *
158:                  * Description:	Configures peripheral bus divisor
159:                  *
160:                  * PreCondition: oscPbDiv one of the OSC_PB_DIV_X valid values
161:                  *
162:                  * Inputs:    oscPbDiv - desired PB divider
163:                  *
164:                  * Output:      None
165:                  *
166:                  * Example:   OSCSetPBDIV(  OSC_PB_DIV_8 )
167:                  *
168:                  ********************************************************************/
169:                 extern inline void __attribute__((always_inline)) OSCSetPBDIV(unsigned int oscPbDiv)
170:                 {
171:                 	unsigned int dma_status;
172:                 	unsigned int int_status;
173:                 	__OSCCONbits_t oscBits;
174:                 
175:                 	mSYSTEMUnlock(int_status, dma_status);
9D000920  0F400514   JAL INTDisableInterrupts
9D000924  00000000   NOP
9D000928  AFC2002C   SW V0, 44(S8)
9D000970  AFC20034   SW V0, 52(S8)
9D000974  3C02BF81   LUI V0, -16511
9D000978  AC40F230   SW ZERO, -3536(V0)
9D00097C  3C02BF81   LUI V0, -16511
9D000980  3C03AA99   LUI V1, -21863
9D000984  34636655   ORI V1, V1, 26197
9D000988  AC43F230   SW V1, -3536(V0)
9D00098C  3C02BF81   LUI V0, -16511
9D000990  3C035566   LUI V1, 21862
9D000994  346399AA   ORI V1, V1, -26198
9D000998  AC43F230   SW V1, -3536(V0)
176:                 	
177:                 	oscBits.w=OSCCON;		// read to be in sync. flush any pending write
9D00099C  3C02BF81   LUI V0, -16511
9D0009A0  8C42F000   LW V0, -4096(V0)
9D0009A4  AFC2004C   SW V0, 76(S8)
178:                 	oscBits.PBDIV=0;
9D0009A8  8FC2004C   LW V0, 76(S8)
9D0009AC  7C02A4C4   INS V0, ZERO, 19, 2
9D0009B0  AFC2004C   SW V0, 76(S8)
179:                 	oscBits.w|=oscPbDiv;	
9D0009B4  8FC3004C   LW V1, 76(S8)
9D0009B8  8FC20028   LW V0, 40(S8)
9D0009BC  00621025   OR V0, V1, V0
9D0009C0  AFC2004C   SW V0, 76(S8)
180:                 	OSCCON=oscBits.w;		// write back
9D0009C4  8FC3004C   LW V1, 76(S8)
9D0009C8  3C02BF81   LUI V0, -16511
9D0009CC  AC43F000   SW V1, -4096(V0)
181:                 	oscBits.w=OSCCON;		// make sure the write occurred before returning from this function
9D0009D0  3C02BF81   LUI V0, -16511
9D0009D4  8C42F000   LW V0, -4096(V0)
9D0009D8  AFC2004C   SW V0, 76(S8)
182:                 	
183:                 	mSYSTEMLock(int_status, dma_status);
9D0009DC  3C02BF81   LUI V0, -16511
9D0009E0  3C033333   LUI V1, 13107
9D0009E4  34633333   ORI V1, V1, 13107
9D0009E8  AC43F230   SW V1, -3536(V0)
9D0009EC  8FC20034   LW V0, 52(S8)
9D0009F0  AFC20038   SW V0, 56(S8)
9D000A5C  8FC4002C   LW A0, 44(S8)
9D000A60  0F400503   JAL INTRestoreInterrupts
9D000A64  00000000   NOP
184:                 }
185:                 
186:                 #define		mOSCSetPBDIV		OSCSetPBDIV		// backward compatibility
187:                 
188:                 
189:                 
190:                 	/******************************************************************************
191:                 	 * Available options for config parameter
192:                 	 *****************************************************************************/
193:                 		// CPU Peripheral Bus divisor values - values are mutually exclusive
194:                 		#define OSC_PB_DIV_8    (3 << _OSCCON_PBDIV_POSITION)
195:                 		#define OSC_PB_DIV_4    (2 << _OSCCON_PBDIV_POSITION)
196:                 		#define OSC_PB_DIV_2    (1 << _OSCCON_PBDIV_POSITION)
197:                 		#define OSC_PB_DIV_1    (0 << _OSCCON_PBDIV_POSITION)
198:                 	/***********************************
199:                 	 * End config parameter values
200:                 	 ************************************/
201:                 
202:                 
203:                 /*********************************************************************
204:                  * Function:    mOSCGetPBDIV()
205:                  *
206:                  * Description:	Reads peripheral bus divisor
207:                  *
208:                  * PreCondition:None
209:                  *
210:                  * Inputs:	  	None
211:                  *
212:                  * Output:      None
213:                  *
214:                  * Example:	  	mOSCGetPBDIV()
215:                  *
216:                  ********************************************************************/
217:                 #define mOSCGetPBDIV() (OSCCONbits.PBDIV)
218:                 
219:                 
220:                 /*********************************************************************
221:                  * Function:    mOSCClockFailStatus()
222:                  *
223:                  * Description:	Returns Clock Fail status. 1 = clock fail, 0 = no clock fail
224:                  *
225:                  * PreCondition: None
226:                  *
227:                  * Inputs:	  	None
228:                  *
229:                  * Output:      None
230:                  *
231:                  * Example:	  	mOSCClockFailStatus()
232:                  *
233:                  ********************************************************************/
234:                 #define mOSCClockFailStatus (OSCCONbits.CF)
235:                 
236:                 
237:                 /*********************************************************************
238:                  * Function:      	mOSCEnableSOSC()
239:                  *
240:                  * Description:	  	Enables the LPRC
241:                  *
242:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
243:                  *
244:                  * Inputs:	  		None
245:                  *
246:                  * Output:        	None
247:                  *
248:                  * Example:	  		mOSCEnableSOSC()
249:                  *
250:                  ********************************************************************/
251:                 #define mOSCEnableSOSC() mSysUnlockOpLock(OSCCONSET = _OSCCON_SOSCEN_MASK)
252:                 
253:                 
254:                 /*********************************************************************
255:                  * Function:      	mOSCDisableSOSC(config)
256:                  *
257:                  * Description:	  	Disables SOSC
258:                  *
259:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
260:                  *
261:                  * Inputs:	  		None
262:                  *
263:                  * Output:        	None
264:                  *
265:                  * Example:	  		mOSCDisableSOSC()
266:                  *
267:                  ********************************************************************/
268:                 #define mOSCDisableSOSC() mSysUnlockOpLock(OSCCONCLR = _OSCCON_SOSCEN_MASK)
269:                 
270:                 
271:                 
272:                 #endif
---  /Applications/microchip/xc32/v1.31/pic32mx/include/peripheral/dma_1xx_2xx.h  -----------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  DMA API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        Dma.h
7:                    * Dependencies:    xc.h
8:                    *                  int.h
9:                    *
10:                   * Processor:       PIC32
11:                   *
12:                   * Compiler:        MPLAB XC32
13:                   *                  MPLAB IDE
14:                   * Company:         Microchip Technology Inc.
15:                   *
16:                   * Software License Agreement
17:                   *
18:                   * The software supplied herewith by Microchip Technology Incorporated
19:                   * (the �Company�) for its PIC32/PIC24F Microcontroller is intended
20:                   * and supplied to you, the Company�s customer, for use solely and
21:                   * exclusively on Microchip PIC32/PIC24F Microcontroller products.
22:                   * The software is owned by the Company and/or its supplier, and is
23:                   * protected under applicable copyright laws. All rights are reserved.
24:                   * Any use in violation of the foregoing restrictions may subject the
25:                   * user to criminal sanctions under applicable laws, as well as to
26:                   * civil liability for the breach of the terms and conditions of this
27:                   * license.
28:                   *
29:                   * THIS SOFTWARE IS PROVIDED IN AN �AS IS� CONDITION. NO WARRANTIES,
30:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
31:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
32:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
33:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
34:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
35:                   *
36:                   *
37:                   * $Id: Dma.h,v 1.9 2007/01/17 21:35:46 C12878 Exp $
38:                   * $Name:  $
39:                   *
40:                   ********************************************************************/
41:                  
42:                  #ifndef _DMA_H_
43:                  #define _DMA_H_
44:                  
45:                  #include <xc.h>
46:                  
47:                  
48:                  // DMA definitions
49:                  
50:                  #ifdef _DMAC0
51:                      #define _DMA_CHANNELS       // DMA channels exist
52:                  
53:                  
54:                  // existent DMA channels
55:                      typedef enum
56:                      {
57:                          DMA_CHANNEL0,
58:                      #ifdef _DMAC1
59:                          DMA_CHANNEL1,
60:                      # ifdef _DMAC2
61:                          DMA_CHANNEL2,
62:                      #  ifdef _DMAC3
63:                          DMA_CHANNEL3,
64:                      #  endif// _DMAC3
65:                      # endif // _DMAC2
66:                      #endif  // _DMAC1
67:                          //  add/remove DMA channel as needed here
68:                  
69:                          DMA_CHANNELS    // number of current available channels
70:                      }DmaChannel;
71:                  
72:                  
73:                      // Relative Dma channels priority, between each other
74:                      typedef enum
75:                      {
76:                          DMA_CHN_PRI0,
77:                          DMA_CHN_PRI1,
78:                          DMA_CHN_PRI2,
79:                          DMA_CHN_PRI3
80:                      }DmaChannelPri;
81:                  
82:                  
83:                  
84:                      // high level definitions for the API functions
85:                  
86:                      typedef enum
87:                      {
88:                          DMA_OPEN_DEFAULT = 0,                                   // DMA default operation
89:                          DMA_OPEN_AUTO   = _DCH0CON_CHAEN_MASK,                  // DMA channel is auto enabled
90:                          DMA_OPEN_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK),   // DMA channel is chained to lower channel
91:                          DMA_OPEN_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),             // DMA channel is chained to higher channel
92:                          DMA_OPEN_DET_EN = _DCH0CON_CHAED_MASK,                  // events detection enabled while channel off
93:                          DMA_OPEN_ENABLE = _DCH0CON_CHEN_MASK,                   // DMA channel is enabled after open
94:                          DMA_OPEN_MATCH  = 0x80000000,                           // DMA channel stops on match
95:                      }DmaOpenFlags;  // flags for the channel open
96:                  
97:                  
98:                      typedef enum
99:                      {
100:                         DMA_EV_ERR =            0x1,        // address error event
101:                         DMA_EV_ABORT =          0x2,        // transfer abort event
102:                         DMA_EV_CELL_DONE =      0x4,        // cell transfer complete event
103:                         DMA_EV_BLOCK_DONE =     0x8,        // block transfer complete event
104:                         DMA_EV_DST_HALF =       0x10,       // destination half event
105:                         DMA_EV_DST_FULL =       0x20,       // destination full event
106:                         DMA_EV_SRC_HALF =       0x40,       // source half event
107:                         DMA_EV_SRC_FULL =       0x80,       // source full event
108:                 
109:                         DMA_EV_ALL_EVNTS=       (DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_CELL_DONE|DMA_EV_BLOCK_DONE|DMA_EV_DST_HALF|
110:                                                     DMA_EV_DST_FULL|DMA_EV_SRC_HALF|DMA_EV_SRC_FULL)                // all available events
111:                     }DmaEvFlags;    // flags for controlling the DMA channel events; Bit fields from the processor header file.
112:                 
113:                 
114:                     typedef enum
115:                     {
116:                         DMA_TXFER_OK,           // the transfer was performed successfully
117:                         DMA_TXFER_ADD_ERR,      // address error while performing the transfer
118:                         DMA_TXFER_ABORT,        // the DMA transfer was aborted
119:                         DMA_TXFER_BC_ERR,       // block complete not set after the DMA transfer performed
120:                         DMA_TXFER_CC_ERR,       // cell complete not set after the DMA transfer performed
121:                         DMA_TXFER_TMO           // DMA transfer timeout
122:                     }DmaTxferRes;       // DMA transfer result
123:                 
124:                     typedef enum
125:                     {
126:                         DMA_WAIT_NOT,       // don't wait for the transfer to complete, return immediately
127:                         DMA_WAIT_CELL,      // wait for the cell transfer to complete, than return
128:                         DMA_WAIT_BLOCK      // wait for the block transfer to complete, than return
129:                     }DmaWaitMode;       // DMA transfer wait mode
130:                 
131:                     typedef enum
132:                     {
133:                         DMA_CHKSUM_CRC,     // LFSR CRC
134:                         DMA_CHKSUM_IP,      // IP Checksum
135:                     }DmaChksumType;     // DMA SFM supported checksum types
136:                 
137:                     typedef enum
138:                     {
139:                         DMA_BITO_MSb,       // MSb first (not reflected)
140:                         DMA_BITO_LSb,       // LSb first (reflected)
141:                     }DmaBitOrder;       // DMA SFM supported bit ordering
142:                 
143:                     typedef enum
144:                     {
145:                         DMA_REORDER_NOT,    // no reordering, destination matches the source
146:                         DMA_REORDER_ENDIAN, // change endianess on word (32 bit) boundaries: LE<->BE
147:                         DMA_REORDER_SWAP_HALF,  // swap half words (16 bit) within word (32 bit)
148:                         DMA_REORDER_SWAP_BYTE,  // swap bytes within half word (16 bit)
149:                     }DmaReorderMode;    // DMA SFM supported re-ordering modes
150:                 
151:                 
152:                     /*********************************************************************
153:                      * Function:        void DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags)
154:                      *
155:                      * PreCondition:    chPri  - valid channel priority, 0-3
156:                      *
157:                      * Input:           chn    - channel to be configured in the DMA controller
158:                      *                  chPri  - the priority given to the channel, 0-3
159:                      *                  oFlags - orred flags specifying the open mode:
160:                      *                           DMA_OPEN_DEFAULT: DMA default operation mode
161:                      *                           DMA_OPEN_AUTO: DMA channel is auto enabled
162:                      *                           DMA_OPEN_CHAIN_LOW: DMA channel is chained to lower channel
163:                      *                           DMA_OPEN_CHAIN_HI: DMA channel is chained to higher channel
164:                      *                           DMA_OPEN_DET_EN: events detection enabled while channel off
165:                      *                           DMA_OPEN_ENABLE: DMA channel is enabled when opened
166:                      *                           DMA_OPEN_MATCH:    DMA channel stops on match
167:                      *
168:                      *
169:                      *
170:                      * Output:          None
171:                      *
172:                      * Side Effects:    None
173:                      *
174:                      * Overview:        The function opens and configures the selected DMA channel using the supplied user flags and priority.
175:                      *
176:                      * Note:            - This is a high level access function that doesn't give access to all the settings possible for a DMA channel.
177:                      *                  Use the low level functions to address special settings.
178:                      *                  - The channel is turned off, the pending interrupts are cleared, interrupts are disabled.
179:                      *                  After that the channel is configured.
180:                      *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
181:                      *                  if DMA_OPEN_ENABLE flag was not specified.
182:                      *                  - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
183:                      *                  This way, the transfer will occur correctly together with CRC calculation.
184:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
185:                      *                  User has to call event channel functions to enable the event flags if needed.
186:                      *
187:                      * Example:         DmaChnOpen(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_OPEN_AUTO|DMA_OPEN_MATCH|DMA_OPEN_ENABLE);
188:                      ********************************************************************/
189:                      void           DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags);
190:                 
191:                     /*********************************************************************
192:                      * Function:        void DmaChnEnable(DmaChannel chn)
193:                      *
194:                      * PreCondition:    None
195:                      *
196:                      * Input:           chn     - channel to be enabled
197:                      *
198:                      * Output:          None
199:                      *
200:                      * Side Effects:    None
201:                      *
202:                      * Overview:        The function enables a previously configured DMA channel.
203:                      *
204:                      * Note:            DmaChnOpen()/DmaChnConfigure() should have been called before.
205:                      *
206:                      * Example:         DmaChnEnable(DMA_CHANNEL3);
207:                      ********************************************************************/
208:                      void           DmaChnEnable(DmaChannel chn);
209:                 
210:                     /*********************************************************************
211:                      * Function:        void DmaChnDisable(DmaChannel chn)
212:                      *
213:                      * PreCondition:    None
214:                      *
215:                      * Input:           chn     - selected channel in the DMA controller
216:                      *
217:                      * Output:          None
218:                      *
219:                      * Side Effects:    None
220:                      *
221:                      * Overview:        The function disables a DMA channel. The channel operation stops.
222:                      *
223:                      * Note:            None.
224:                      *
225:                      * Example:         DmaChnDisable(DMA_CHANNEL3);
226:                      ********************************************************************/
227:                      void           DmaChnDisable(DmaChannel chn);
228:                 
229:                     /*********************************************************************
230:                      * Function:        void DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize)
231:                      *
232:                      * PreCondition:    chn     - valid DMA channel
233:                      *              - vSrcAdd, vDstAdd  - valid pointers
234:                      *                              - 0 < srcSize <= DmaGetMaxTxferSize()
235:                      *                              - 0 < dstSize <= DmaGetMaxTxferSize()
236:                      *                              - 0 < cellSize <= DmaGetMaxTxferSize()
237:                      *
238:                      * Input:           chn         - DMA channel number
239:                      *                              - vSrcAdd: source of the DMA transfer
240:                      *                              - vDstAdd: destination of the DMA transfer
241:                      *                              - srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
242:                      *                              - dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
243:                      *                              - cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
244:                      *
245:                      * Output:          None
246:                      *
247:                      * Side Effects:    None
248:                      *
249:                      * Overview:        The function sets the transfer characteristics for a DMA channel transfer:
250:                      *                  the source and the destination addresses.
251:                      *                  the source and destination lengths
252:                      *                  and the number of bytes transferred per event.
253:                      *
254:                      * Note:            The function clears the existing DMA channel event flags.
255:                      *                  The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
256:                      *
257:                      * Example:         DmaChnSetTxfer(DMA_CHANNEL3, &U2RXREG, dstBuff, 1, 200, 1);
258:                      ********************************************************************/
259:                      void           DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize);
260:                 
261:                 
262:                     /*********************************************************************
263:                      * Function:        void DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd)
264:                      *
265:                      * PreCondition:    chn     - valid DMA channel
266:                      *
267:                      * Input:           chn     - DMA channel number
268:                      *              - vSrcAdd: source (virtual) of the DMA transfer
269:                      * Output:          None
270:                      *
271:                      * Side Effects:    None
272:                      *
273:                      * Overview:        The function is a helper to set directly the transfer source address.
274:                      *
275:                      * Note:            None.
276:                      *
277:                      * Example:         DmaChnSetSrcAdd(DMA_CHANNEL2, srcBuff+sizeof(srcBuff));
278:                      ********************************************************************/
279:                      void           DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd);
280:                 
281:                     /*********************************************************************
282:                      * Function:        void DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd)
283:                      *
284:                      * PreCondition:    chn     - valid DMA channel
285:                      *
286:                      * Input:           chn         - DMA channel number
287:                      *                              - vDstAdd: destination (virtual) of the DMA transfer
288:                      * Output:          None
289:                      *
290:                      * Side Effects:    None
291:                      *
292:                      * Overview:        The function is a helper to set directly the transfer destination address.
293:                      *
294:                      * Note:            None
295:                      *
296:                      * Example:         DmaChnSetDstAdd(DMA_CHANNEL2, dstBuff+sizeof(dstBuff));
297:                      ********************************************************************/
298:                      void           DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd);
299:                 
300:                     /*********************************************************************
301:                      * Function:        void DmaChnSetMatchPattern(DmaChannel chn, int pattern)
302:                      *
303:                      * PreCondition:    chn - valid DMA channel
304:                      *
305:                      * Input:           chn     - DMA channel number
306:                      *                  pattern -  the match pattern
307:                      *
308:                      * Output:          None
309:                      *
310:                      * Side Effects:    None
311:                      *
312:                      * Overview:        The function sets the curent match pattern for the selected DMA channel.
313:                      *
314:                      * Note:            None.
315:                      *
316:                      * Example:         DmaChnSetMatchPattern(DMA_CHANNEL3, '\r');
317:                      ********************************************************************/
318:                      void           DmaChnSetMatchPattern(DmaChannel chn, int pattern);
319:                 
320:                     /*********************************************************************
321:                      * Function:        int DmaChnGetMatchPattern(DmaChannel chn)
322:                      *
323:                      * PreCondition:    chn - valid DMA channel
324:                      *
325:                      * Input:           chn     - DMA channel number
326:                      *
327:                      * Output:          The channel match pattern.
328:                      *
329:                      * Side Effects:    None
330:                      *
331:                      * Overview:        The function retrieves the curent match pattern for the selected DMA channel.
332:                      *
333:                      * Note:            None.
334:                      *
335:                      * Example:         int pattern=DmaChnGetMatchPattern(DMA_CHANNEL3);
336:                      ********************************************************************/
337:                      int            DmaChnGetMatchPattern(DmaChannel chn);
338:                 
339:                     /*********************************************************************
340:                      * Function:        DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries)
341:                      *
342:                      * PreCondition:    chn - valid DMA channel
343:                      *
344:                      * Input:           chn     - DMA channel number
345:                      *                  wMode   - if DMA_WAIT_NOT, return immediately
346:                      *                          - if DMA_WAIT_CELL, return after the cell transfer complete
347:                      *                          - if DMA_WAIT_BLOCK, return after the whole transfer is done
348:                      *                  retries - retry counter: if transfer not complete after so many retries, return with tmo.
349:                      *                              If 0, wait forever.
350:                      *
351:                      * Output:          DMA_TXFER_OK if not waiting for the transfer completion or if the transfer ended normally,
352:                      *                  an DmaTxferRes error code  otherwise
353:                      *
354:                      * Side Effects:    None
355:                      *
356:                      * Overview:        The function initiates (forces) a DMA transfer for the selected DMA channel.
357:                      *                  The DMA channel is enabled.
358:                      *                  If waiting for the transfer completion needed (user doesn't use an ISR to catch
359:                      *                  this event) the function will periodically query the DMA controller for the
360:                      *                  transfer completion status.
361:                      *                  If DMA_WAIT_BLOCK is specified and multiple cell transfers are needed to complete
362:                      *                  the block transfer than the function will re-force the transfer for each cell.
363:                      *
364:                      * Note:            This function can not ne used when the DMA channel is triggerred
365:                      *                  by hardware interrupt requests.
366:                      *                  This is because the transfers are software forced, theere is no
367:                      *                  wait for the occurrence of the hardware trigger.
368:                      *
369:                      * Example:         DmaChnStartTxfer(DMA_CHANNEL2, DMA_WAIT_BLOCK, 0);
370:                      ********************************************************************/
371:                      DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries);
372:                 
373:                     /*********************************************************************
374:                      * Function:        void DmaChnForceTxfer(DmaChannel chn)
375:                      *
376:                      * PreCondition:    chn - valid DMA channel
377:                      *
378:                      * Input:           chn     - DMA channel number
379:                      *
380:                      * Output:          None
381:                      *
382:                      * Side Effects:    None
383:                      *
384:                      * Overview:        The function forces a DMA transfer to occur for the selected DMA channel.
385:                      *
386:                      * Note:            None.
387:                      *
388:                      * Example:         DmaChnForceTxfer(DMA_CHANNEL3);
389:                      ********************************************************************/
390:                      void           DmaChnForceTxfer(DmaChannel chn);
391:                 
392:                     /*********************************************************************
393:                      * Function:        void DmaChnAbortTxfer(DmaChannel chn)
394:                      *
395:                      * PreCondition:    chn - valid DMA channel
396:                      *
397:                      * Input:           chn     - DMA channel number
398:                      *
399:                      * Output:          None
400:                      *
401:                      * Side Effects:    None
402:                      *
403:                      * Overview:        The function aborts a current undergoing DMA transfer for the selected DMA channel.
404:                      *
405:                      * Note:            None.
406:                      *
407:                      * Example:         DmaChnAbortTxfer(DMA_CHANNEL3);
408:                      ********************************************************************/
409:                      void           DmaChnAbortTxfer(DmaChannel chn);
410:                 
411:                     // High level channel event and interrupt control functions
412:                 
413:                     /*********************************************************************
414:                      * Function:        void DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
415:                      *
416:                      * PreCondition:    chn - valid DMA channel
417:                      *
418:                      * Input:           chn     - DMA channel number
419:                      *                  eFlags  - event flags with the following significance:
420:                      *                              - DMA_EV_ERR: address error event
421:                      *                              - DMA_EV_ABORT: transfer abort event
422:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
423:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
424:                      *                              - DMA_EV_DST_HALF: destination half event
425:                      *                              - DMA_EV_DST_FULL: destination full event
426:                      *                              - DMA_EV_SRC_HALF: source half event
427:                      *                              - DMA_EV_SRC_FULL: source full event
428:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
429:                      *
430:                      * Output:          None
431:                      *
432:                      * Side Effects:    None
433:                      *
434:                      * Overview:        The function sets the event enable flags for the selected DMA channel.
435:                      *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
436:                      *                  enabled for the selected channel, the other channel event flags won't be touched.
437:                      *
438:                      * Note:            None.
439:                      *
440:                      * Example:         DmaChnSetEvEnableFlags(DMA_CHANNEL3, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
441:                      ********************************************************************/
442:                      void           DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
443:                 
444:                     /*********************************************************************
445:                      * Function:        void DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
446:                      *
447:                      * PreCondition:    chn - valid DMA channel
448:                      *
449:                      * Input:           chn     - DMA channel number
450:                      *                  eFlags  - event flags with the following significance:
451:                      *                              - DMA_EV_ERR: address error event
452:                      *                              - DMA_EV_ABORT: transfer abort event
453:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
454:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
455:                      *                              - DMA_EV_DST_HALF: destination half event
456:                      *                              - DMA_EV_DST_FULL: destination full event
457:                      *                              - DMA_EV_SRC_HALF: source half event
458:                      *                              - DMA_EV_SRC_FULL: source full event
459:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
460:                      *
461:                      * Output:          None
462:                      *
463:                      * Side Effects:    None
464:                      *
465:                      * Overview:        The function clears the event enable flags for the selected DMA channel.
466:                      *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
467:                      *                  disabled for the selected channel, the other channel event flags won't be touched.
468:                      *
469:                      * Note:            None.
470:                      *
471:                      * Example:         DmaChnClrEvEnableFlags(DMA_CHANNEL3, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
472:                      ********************************************************************/
473:                      void           DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
474:                 
475:                     /*********************************************************************
476:                      * Function:        void DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
477:                      *
478:                      * PreCondition:    chn - valid DMA channel
479:                      *
480:                      * Input:           chn     - DMA channel number
481:                      *                  eFlags  - event flags with the following significance:
482:                      *                              - DMA_EV_ERR: address error event
483:                      *                              - DMA_EV_ABORT: transfer abort event
484:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
485:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
486:                      *                              - DMA_EV_DST_HALF: destination half event
487:                      *                              - DMA_EV_DST_FULL: destination full event
488:                      *                              - DMA_EV_SRC_HALF: source half event
489:                      *                              - DMA_EV_SRC_FULL: source full event
490:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
491:                      *
492:                      * Output:          None
493:                      *
494:                      * Side Effects:    None
495:                      *
496:                      * Overview:        The function sets the event enable flags for the selected DMA channel.
497:                      *                  The channel event flags are forced to the eFlags value.
498:                      *
499:                      * Note:            None.
500:                      *
501:                      * Example:         DmaChnWriteEvEnableFlags(DMA_CHANNEL3, DMA_EV_ALL_EVNTS);
502:                      ********************************************************************/
503:                      void           DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
504:                 
505:                     /*********************************************************************
506:                      * Function:        DmaEvFlags DmaChnGetEvEnableFlags(DmaChannel chn)
507:                      *
508:                      * PreCondition:    chn - valid DMA channel
509:                      *
510:                      * Input:           chn     - DMA channel number
511:                      *
512:                      * Output:          - event flags with the following significance:
513:                      *                      - DMA_EV_ERR: address error event
514:                      *                      - DMA_EV_ABORT: transfer abort event
515:                      *                      - DMA_EV_CELL_DONE: cell transfer complete event
516:                      *                      - DMA_EV_BLOCK_DONE: block transfer complete event
517:                      *                      - DMA_EV_DST_HALF: destination half event
518:                      *                      - DMA_EV_DST_FULL: destination full event
519:                      *                      - DMA_EV_SRC_HALF: source half event
520:                      *                      - DMA_EV_SRC_FULL: source full event
521:                      *                      - DMA_EV_ALL_EVNTS: all of the above flags
522:                      *
523:                      * Side Effects:    None
524:                      *
525:                      * Overview:        The function returns the event enabled flags for the selected DMA channel.
526:                      *
527:                      * Note:            None.
528:                      *
529:                      * Example:         DmaEvFlags enabledFlags=DmaChnGetEvEnableFlags(DMA_CHANNEL3);
530:                      ********************************************************************/
531:                      DmaEvFlags DmaChnGetEvEnableFlags(DmaChannel chn);
532:                 
533:                     /*********************************************************************
534:                      * Function:        void DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags)
535:                      *
536:                      * PreCondition:    chn - valid DMA channel
537:                      *
538:                      * Input:           chn     - DMA channel number
539:                      *                  eFlags  - event flags with the following significance:
540:                      *                              - DMA_EV_ERR: address error event
541:                      *                              - DMA_EV_ABORT: transfer abort event
542:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
543:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
544:                      *                              - DMA_EV_DST_HALF: destination half event
545:                      *                              - DMA_EV_DST_FULL: destination full event
546:                      *                              - DMA_EV_SRC_HALF: source half event
547:                      *                              - DMA_EV_SRC_FULL: source full event
548:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
549:                      *
550:                      * Output:          None
551:                      *
552:                      * Side Effects:    None
553:                      *
554:                      * Overview:        The function clears the event flags for the selected DMA channel.
555:                      *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
556:                      *                  cleared for the selected channel, the other channel event flags won't be touched.
557:                      *
558:                      * Note:            None.
559:                      *
560:                      * Example:         DmaChnClrEvFlags(DMA_CHANNEL3, DMA_EV_ALL_EVNTS);
561:                      ********************************************************************/
562:                      void           DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags);
563:                 
564:                     /*********************************************************************
565:                      * Function:        DmaEvFlags DmaChnGetEvFlags(DmaChannel chn)
566:                      *
567:                      * PreCondition:    chn - valid DMA channel
568:                      *
569:                      * Input:           chn     - DMA channel number
570:                      *
571:                      * Output:          event flags with the following significance:
572:                      *                      - DMA_EV_ERR: address error event
573:                      *                      - DMA_EV_ABORT: transfer abort event
574:                      *                      - DMA_EV_CELL_DONE: cell transfer complete event
575:                      *                      - DMA_EV_BLOCK_DONE: block transfer complete event
576:                      *                      - DMA_EV_DST_HALF: destination half event
577:                      *                      - DMA_EV_DST_FULL: destination full event
578:                      *                      - DMA_EV_SRC_HALF: source half event
579:                      *                      - DMA_EV_SRC_FULL: source full event
580:                      *                      - DMA_EV_ALL_EVNTS: all of the above flags
581:                      *
582:                      * Side Effects:    None
583:                      *
584:                      * Overview:        The function returns the event flags for the selected DMA channel.
585:                      *
586:                      * Note:            None.
587:                      *
588:                      * Example:         DmaEvFlags intSetFlags=DmaChnGetEvFlags(DMA_CHANNEL3);
589:                      ********************************************************************/
590:                      DmaEvFlags DmaChnGetEvFlags(DmaChannel chn);
591:                 
592:                 
593:                     // high level helpers for fast strcpy/memcpy transfers
594:                 
595:                     /*********************************************************************
596:                      * Function:        DmaTxferRes DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri)
597:                      *
598:                      * PreCondition:    chn     - a valid DMA channel
599:                      *                  s1, s2  - valid memory pointers
600:                      *                  n>0, n<=DmaGetMaxTxferSize()
601:                      *
602:                      * Input:           s1      - destination pointer
603:                      *                  s2      - source pointer
604:                      *                  n       - number of bytes to transfer
605:                      *                  chn     - the DMA channel to perform the transfer
606:                      *                  chPri   - the desired channel priority
607:                      *
608:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
609:                      *                  an DmaTxferRes error code  otherwise
610:                      *
611:                      * Side Effects:    None
612:                      *
613:                      * Overview:        The function configures a DMA channel for a fast memory transfer.
614:                      *          Then it copies one block of memory from source to destination.
615:                      *
616:                      *
617:                      * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
618:                      *                    This way, the transfer will occur correctly together with checksum calculation.
619:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
620:                      *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
621:                      *                  - The function clears the suspend state and resumes the operation of the DMA controller.
622:                      *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
623:                      *
624:                      * Example:     res=DmaChnMemcpy(pDst, pSrc, buffSz, DMA_CHANNEL0, DMA_CHN_PRI3);
625:                      ********************************************************************/
626:                      DmaTxferRes    DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri);
627:                 
628:                     /*********************************************************************
629:                      * Function:        DmaTxferRes DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri)
630:                      *
631:                      * PreCondition:    chn     - a valid DMA channel
632:                      *                  s1, s2  - valid memory pointers
633:                      *
634:                      * Input:           s1      - destination pointer
635:                      *                  s2      - source pointer
636:                      *                  chn     - the DMA channel to perform the transfer
637:                      *                  chPri   - the desired channel priority
638:                      *
639:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
640:                      *                  an DmaTxferRes error code  otherwise
641:                      *
642:                      * Side Effects:    None
643:                      *
644:                      * Overview:        The function configures a DMA channel for a fast memory transfer.
645:                      *          Then it copies one zero terminated string from source to destination.
646:                      *
647:                      *
648:                      * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
649:                      *                    This way, the transfer will occur correctly together with checksum calculation.
650:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
651:                      *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
652:                      *                  - The function clears the suspend state and resumes the operation of the DMA controller.
653:                      *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
654:                      *
655:                      *
656:                      * Example:     res=DmaChnStrcpy(str1, str2, DMA_CHANNEL1, DMA_CHN_PRI3);
657:                      *********************************************************************/
658:                      DmaTxferRes    DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri);
659:                 
660:                     /*********************************************************************
661:                      * Function:        DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri)
662:                      *
663:                      * PreCondition:    chn     - a valid DMA channel
664:                      *              - s1, s2    - valid memory pointers
665:                      *                              - 0 < n <= DmaGetMaxTxferSize()
666:                      *
667:                      * Input:           s1      - destination pointer
668:                      *                  s2      - source pointer
669:                      *                  n   - max number of bytes to transfer
670:                      *                  chn     - the DMA channel to perform the transfer
671:                      *                  chPri   - the desired channel priority
672:                      *
673:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
674:                      *                  an DmaTxferRes error code  otherwise
675:                      *
676:                      * Side Effects:    None
677:                      *
678:                      * Overview:        The function configures a DMA channel for a fast memory transfer.
679:                      *          Then it copies one zero terminated string from source to destination.
680:                      *          It copies no more than n characters from s2.
681:                      *
682:                      *
683:                      * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
684:                      *                    This way, the transfer will occur correctly together with checksum calculation.
685:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
686:                      *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
687:                      *                  - The function clears the suspend state and resumes the operation of the DMA controller.
688:                      *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
689:                      *
690:                      *
691:                      * Example:     res=DmaChnStrncpy(str1, str2, MAX_STR_LEN, DMA_CHANNEL1, DMA_CHN_PRI3);
692:                      ********************************************************************/
693:                      DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri);
694:                 
695:                     /*********************************************************************
696:                      * Function:        DmaTxferRes DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
697:                      *
698:                      * PreCondition:    chn    - a valid DMA channel
699:                      *                  d, s   - valid memory pointer
700:                      *                  n>0, n<=DmaGetMaxTxferSize()
701:                      *
702:                      * Input:           d     - address where to deposit the result
703:                      *                  s     - source buffer pointer
704:                      *                  n     - number of bytes in the pointer
705:                      *                  chn   - the DMA channel to use
706:                      *                  chPri - the desired channel priority
707:                      *
708:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
709:                      *                  an DmaTxferRes error code  otherwise
710:                      *
711:                      * Side Effects:    None
712:                      *
713:                      * Overview:        The function is a helper that calculates the CRC of a memory block.
714:                      *                  The function configures the DMA channel for a fast memory transfer and calculates the CRC.
715:                      *
716:                      *
717:                      * Note:            - The CRC generator must have been previously configured using DmaSfmCrcConfigure()
718:                      *                  - No transfer is done, just the CRC is calculated.
719:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
720:                      *                  - Append mode is enabled and the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
721:                      *                  - The checksum type is switched to CRC.
722:                      *                  - The way the data is fed into the checksum calculation block is affected by DmaSfmConfigure().
723:                      *
724:                      * Example:          int myCrc; DmaChnMemCrc(&myCrc, srcBuff, sizeof(srcBuff), DMA_CHANNEL2, DMA_CHN_PRI3);
725:                      ********************************************************************/
726:                      DmaTxferRes    DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
727:                 
728:                     /*********************************************************************
729:                      * Function:        DmaTxferRes DmaChnMemChecksum(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
730:                      *
731:                      * PreCondition:    chn    - a valid DMA channel
732:                      *                  d, s   - valid memory pointer
733:                      *                  n>0, n<=DmaGetMaxTxferSize()
734:                      *
735:                      * Input:           d     - address where to deposit the result
736:                      *                  s     - source buffer pointer
737:                      *                  n     - number of bytes in the pointer
738:                      *                  chn   - the DMA channel to use
739:                      *                  chPri - the desired channel priority
740:                      *
741:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
742:                      *                  an DmaTxferRes error code  otherwise
743:                      *
744:                      * Side Effects:    None
745:                      *
746:                      * Overview:        The function is a helper that calculates the IP checksum of a memory block.
747:                      *                  The function configures the DMA channel for a fast memory transfer and calculates the IP checksum.
748:                      *
749:                      *
750:                      * Note:            - The checksum generator must have been previously seeded using DmaSfmSetSeed()
751:                      *                  - No transfer is done, just the checksum is calculated.
752:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
753:                      *                  - Append mode is enabled and the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
754:                      *                  - The checksum type is switched to IP checksum.
755:                      *                  - The way the data is fed into the checksum calculation block is affected by DmaSfmConfigure().
756:                      *
757:                      * Example:          int myChecksum; DmaChnMemChecksum(&myChecksum, srcBuff, sizeof(srcBuff), DMA_CHANNEL1, DMA_CHN_PRI3);
758:                      ********************************************************************/
759:                      DmaTxferRes    DmaChnMemChecksum(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
760:                 
761:                     // High level Special Function Module (SFM) functions
762:                 
763:                     /*********************************************************************
764:                      * Function:        void DmaSfmConfigure(DmaChksumType cType, DmaBitOrder bitO, DmaReorderMode rMode)
765:                      *
766:                      * PreCondition:    cType, bitO, rMode - valid values
767:                      *
768:                      * Input:           cType - checksum type to be calculated: CRC or IP Checksum
769:                      *                  bitO  - the bit order to be used MSb or LSb first
770:                      *                  rMode - the reordering mode of the bytes when calculating the checksum
771:                      *
772:                      * Output:          None
773:                      *
774:                      * Side Effects:    Whenever the Transfer re-ordering is enabled the rMode setting will influence the destination data layout
775:                      *
776:                      * Overview:        The function configures the SFM module by setting the parameters that define the behavior:
777:                      *                      - the type of the checksum to be calculated (either CRC or IP checksum are supported)
778:                      *                      - the bit ordering (how a specific byte is used in the checksum calculation: MSb or LSb first)
779:                      *                      - the data re-ordering (how bytes are re-ordered before calculating the checksum).
780:                      *                      All these values affect the way the checksum is calculated.
781:                      *
782:                      * Note:            None
783:                      *
784:                      * Example:         DmaSfmConfigure(DMA_CHKSUM_CRC, DMA_BITO_LSb, DMA_REORDER_ENDIAN);
785:                      ********************************************************************/
786:                     extern __inline__ void __attribute__((always_inline)) DmaSfmConfigure(DmaChksumType cType, DmaBitOrder bitO, DmaReorderMode rMode)
787:                     {
788:                         DCRCCONCLR=_DCRCCON_CRCTYP_MASK|_DCRCCON_BITO_MASK|_DCRCCON_BYTO_MASK;
789:                         DCRCCONSET=(cType<<_DCRCCON_CRCTYP_POSITION)|(bitO<<_DCRCCON_BITO_POSITION)|(rMode<<_DCRCCON_BYTO_POSITION);
790:                     }
791:                 
792:                     /*********************************************************************
793:                      * Function:        void DmaSfmTxferReorder(int enable)
794:                      *
795:                      * PreCondition:    None
796:                      *
797:                      * Input:           enable - boolean to enable/disable the re-ordering of the data transfer
798:                      *
799:                      * Output:          None
800:                      *
801:                      * Side Effects:    None
802:                      *
803:                      * Overview:        The function configures the data transfer re-ordering of the SFM module.
804:                      *                  If the re-ordering is enabled, the data is read from the source, re-ordered accordingly and then written to the destination.
805:                      *                  Otherwise the data is written to the destination un-modified.
806:                      *                  The re-ordering is the one specified by the DmaReorderMode parameter in the DmaSfmConfigure() call.
807:                      *
808:                      *
809:                      * Note:            - The data transfer re-ordering should be used only for normal (background mode) data transfers.
810:                      *                  - In append mode the data transfer re-ordering should not be enabled (undefined behavior)!
811:                      *                  - Whenever the data re-ordering is enabled, the transfer should be aligned at both ends (source and destination).
812:                      *                    Un-aligned transfers are not supported (undefined behavior)!
813:                      *
814:                      * Example:         DmaSfmTxferReorder();
815:                      ********************************************************************/
816:                     extern __inline__ void __attribute__((always_inline)) DmaSfmTxferReorder(int enable)
817:                     {
818:                         DCRCCONCLR=_DCRCCON_WBO_MASK;
819:                         DCRCCONSET=(enable<<_DCRCCON_WBO_POSITION);
820:                     }
821:                 
822:                 
823:                      /*********************************************************************
824:                      * Function:        void DmaSfmCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
825:                      *
826:                      * PreCondition:    pLen   - valid polynomial length within 1-32
827:                      *
828:                      * Input:           polynomial  - the layout of the CRC generator
829:                      *                  pLen        - the length of the CRC generator polynomial
830:                      *                  seed        - the initial seed of the CRC generator
831:                      *
832:                      * Output:          None
833:                      *
834:                      * Side Effects:    None
835:                      *
836:                      * Overview:        The function configures the SFM CRC module by setting the parameters that define the generator polynomial:
837:                      *                  - the length of the CRC generator polynomial, pLen;
838:                      *                  - the function sets the layout of the shift stages that take place in the CRC generation.
839:                      *                    Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
840:                      *                    If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
841:                      *                    Note that in a proper CRC polynomial, both the most significant bit (MSb) and least significant bit(LSb)
842:                      *                    are always a '1'. Considering the generator polynomial: X^16+X^15+X^2+1, the value to be written as
843:                      *                    feedback should be 0x8005, or 0x8004, but not 0x018005;
844:                      *                  - the function sets the seed of the CRC generator. This is the initial data present in the
845:                      *                   CRC shift register before the CRC calculation begins. A good initial value is usually 0xffffffff.
846:                      *
847:                      * Note:            - Bit 0 of the generator polynomial is always XOR'ed.
848:                      *                  - When the append mode is set, the attached DMA channel has to have destination size <=4.
849:                      *                    Upon the transfer completion the calculated CRC is stored at the destination address.
850:                      *                  - When append mode is cleared, the DMA transfer occurs normally, and the CRC value is available using
851:                      *                    the CrcResult() function.
852:                      *                  - The CRC module should be configured before enabled.
853:                      *                  - These settings are relevant only when the SFM is configured for the CRC type of checksum.
854:                      *                  - The checksum register is the same for CRC or IP checksum mode. Therefore, this function changes also the seed for the IP checksum.
855:                      *                  - The way the data is fed into the checksum calculation block and the type of the checksum performed is affected by DmaSfmConfigure().
856:                      *
857:                      * Example:         DmaSfmCrcConfigure(0x04c11db7, 32, 0xffffffff);
858:                      ********************************************************************/
859:                     extern __inline__ void __attribute__((always_inline)) DmaSfmCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
860:                     {
861:                         DCRCCONCLR=_DCRCCON_PLEN_MASK;
862:                         DCRCCONSET=(pLen-1)<<_DCRCCON_PLEN_POSITION;
863:                         DCRCDATA=seed;
864:                         DCRCXOR=polynomial;
865:                     }
866:                 
867:                     #define DmaCrcConfigure DmaSfmCrcConfigure  // PIC32_3xx backward compatibility name
868:                 
869:                 
870:                     /*********************************************************************
871:                      * Function:        void DmaSfmAttachChannel(DmaChannel chn, int appendMode)
872:                      *
873:                      * PreCondition:    chn    - valid DMA channel
874:                      *
875:                      * Input:           chn         - the DMA channel to be attached to the checksum module.
876:                      *                  appendMode  - if TRUE the data passed to the checksum generator is not transferred to destination
877:                      *                                but it's written to the destination address when the block transfer is complete.
878:                      *                              - if FALSE the data is transferred normally while the checksum is calculated.
879:                      *                                The checksum will be available using the DmaSfmChecksum function.
880:                      *
881:                      * Output:          None
882:                      *
883:                      * Side Effects:    None
884:                      *
885:                      * Overview:        The function attaches the SFM checksum module to a DMA channel and enables the checksum generator.
886:                      *                  From now on, all the DMA traffic is directed to the SFM checksum generator. Once the DMA block transfer
887:                      *                  is complete, the checksum result is available in the checksum data register.
888:                      *                  If append mode is enabled, no data transfer takes place but the checksum result will be deposited at the DMA destination address.
889:                 
890:                      *
891:                      * Note:            If append mode is enabled the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
892:                      *
893:                      * Example:         DmaSfmAttachChannel(DMA_CHANNEL0, TRUE);
894:                      ********************************************************************/
895:                     void            DmaSfmAttachChannel(DmaChannel chn, int appendMode);
896:                     #define         CrcAttachChannel    DmaSfmAttachChannel     // PIC32_3xx backward compatibility name
897:                 
898:                     /*********************************************************************
899:                      * Function:        unsigned int DmaSfmChecksum(void)
900:                      *
901:                      * PreCondition:    None
902:                      *
903:                      * Input:           None
904:                      *
905:                      * Output:          the current value of the checksum generator.
906:                      *
907:                      * Side Effects:    None
908:                      *
909:                      * Overview:        The function returns the calculated checksum value.
910:                      *
911:                      * Note:            - The function returns the valid checksum result. The masking out the unused MSbits in the checksum register is done by the hardware.
912:                      *                  - The way the data is fed into the checksum calculation block and the type of the checksum performed is affected by DmaSfmConfigure().
913:                      *
914:                      * Example:         unsigned int myChk=DmaSfmChecksum();
915:                      ********************************************************************/
916:                     extern __inline__ int __attribute__((always_inline)) DmaSfmChecksum(void)
917:                     {
918:                         return DCRCDATA;
919:                     }
920:                     #define     CrcResult   DmaSfmChecksum      // PIC32_3xx backward compatibility name
921:                     #define     DmaCrcGetValue  DmaSfmChecksum      // PIC32_3xx backward compatibility name
922:                 
923:                 
924:                     /*********************************************************************
925:                      * Function:        void DmaSfmSetSeed(unsigned int seed)
926:                      *
927:                      * PreCondition:    None
928:                      *
929:                      * Input:           seed    - the initial seed of the checksum generator
930:                      *
931:                      * Output:          None
932:                      *
933:                      * Side Effects:    None
934:                      *
935:                      * Overview:        The function sets the seed of the checksum generator. This is the initial data present in the
936:                      *                  CRC shift register or the IP checksum calculator before the actual transfer/calculation begins.
937:                      *
938:                      * Note:            When the SFM is configured for IP checksum mode, only the least significant 16 bits are relevant.
939:                      *
940:                      * Example:         DmaSfmSetSeed(0xffffffff);
941:                      ********************************************************************/
942:                     extern __inline__ void __attribute__((always_inline)) DmaSfmSetSeed(unsigned int seed)
943:                     {
944:                         DCRCDATA=seed;
945:                     }
946:                     #define     DmaCrcSetSeed   DmaSfmSetSeed       // PIC32_3xx backward compatibility name
947:                 
948:                 
949:                 /*********************  end of high level functions ****************************************/
950:                 
951:                     // low level definitions for the API functions
952:                 
953:                 
954:                     typedef struct
955:                     {
956:                         union
957:                         {
958:                             struct
959:                             {
960:                                 unsigned int chn:   3;      // last active DMA channel
961:                                 unsigned int rdOp:  1;      // last DMA operation, read if 1, write if 0
962:                             };
963:                             unsigned int    w;                      // word access
964:                         }lastAccess;
965:                         void*   lastAddress;        // most recent DMA address
966:                     }DmaStatus;         // DMA controller status
967:                 
968:                     typedef enum
969:                     {
970:                         DMA_GFLG_SUSPEND =  _DMACON_SUSPEND_MASK,   // suspend DMA controller operation
971:                         DMA_GFLG_ON =       _DMACON_ON_MASK,        // DMA module enabled/desabled
972:                         //
973:                         DMA_GFLG_ALL_FLAGS= DMA_GFLG_SUSPEND|DMA_GFLG_ON        // all flags
974:                     }DmaGlblFlags;  // flags for controlling global DMA controller behavior. From processor header file.
975:                 
976:                 
977:                 
978:                 
979:                     typedef enum
980:                     {
981:                         DMA_EV_ABORT_IRQ_EN =       _DCH0ECON_AIRQEN_MASK,
982:                         DMA_EV_START_IRQ_EN =       _DCH0ECON_SIRQEN_MASK,
983:                         // use DMA_EV_START_IRQ() and DMA_EV_ABORT_IRQ() below for selecting
984:                         // the start and abort IRQ signals
985:                         DMA_EV_MATCH_EN =           _DCH0ECON_PATEN_MASK,
986:                 
987:                 
988:                         // compiler use only field
989:                         _DMA_EV_MAX_MASK =     _DCH0ECON_CHAIRQ_MASK,
990:                     }DmaEvCtrlFlags;    // DMA channel event control fields accessibile as flags
991:                     // also part of DmaEvCtrlFlags:
992:                     #define DMA_EV_START_IRQ(irq)   (DMA_EV_START_IRQ_EN | ((irq)<<_DCH0ECON_CHSIRQ_POSITION))  // NOTE: irq has to be a symbol from the processor header file
993:                     #define DMA_EV_ABORT_IRQ(irq)   (DMA_EV_ABORT_IRQ_EN | ((irq)<<_DCH0ECON_CHAIRQ_POSITION))  // NOTE: irq has to be a symbol from the processor header file
994:                 
995:                     // DMA channel event control as a structure:
996:                     #define DmaEvCtrl   __DCH0ECONbits_t
997:                 
998:                 
999:                 
1000:                
1001:                    typedef enum
1002:                    {
1003:                        DMA_CTL_AUTO_EN =       _DCH0CON_CHAEN_MASK,
1004:                        DMA_CTL_CHAIN_EN =      _DCH0CON_CHCHN_MASK,
1005:                        DMA_CTL_DET_EN =        _DCH0CON_CHAED_MASK,
1006:                        DMA_CTL_CHN_EN =        _DCH0CON_CHEN_MASK,
1007:                        DMA_CTL_CHAIN_DIR =     _DCH0CON_CHCHNS_MASK,
1008:                        // use the DMA_CTL_PRI() below for selecting the DMA
1009:                        // channel priority
1010:                    }DmaChnCtrlFlags;   // controlling the DMA channel with flags
1011:                    // also part of DmaChnCtrlFlags:
1012:                    #define DMA_CTL_PRI(pri)    ((pri)&_DCH0CON_CHPRI_MASK) // DMA Control channel priority
1013:                
1014:                    // DMA channel control as a structure:
1015:                    #define DmaChnCtrl      __DCH0CONbits_t
1016:                
1017:                    typedef struct
1018:                    {
1019:                        void*   vSrcAdd;        // source of the DMA transfer, virtual
1020:                        void*   vDstAdd;        // destination of the DMA transfer, virtual
1021:                        int srcSize;        // source buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
1022:                        int dstSize;        // destination buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
1023:                        int cellSize;       // no of bytes txferred per event, 1 to DmaGetMaxTxferSize().
1024:                    }DmaTxferCtrl;      // transfer setting: the transfer source, destination addresses and size, cell size
1025:                
1026:                
1027:                    /********************** low level DMA channel functions *******************************/
1028:                
1029:                
1030:                
1031:                    // Global DMA controller functions
1032:                
1033:                    /*********************************************************************
1034:                     * Function:        void DmaEnable(int enable)
1035:                     *
1036:                     * PreCondition:    None
1037:                     *
1038:                     * Input:           enable - boolean to enable/disable the DMA controller
1039:                     *
1040:                     * Output:          None
1041:                     *
1042:                     * Side Effects:    None
1043:                     *
1044:                     * Overview:       The function enables/disables the DMA controller.
1045:                     *
1046:                     * Note:           None.
1047:                     *
1048:                     * Example:        DmaEnable(1);
1049:                     ********************************************************************/
1050:                    extern __inline__ void __attribute__((always_inline)) DmaEnable(int enable)
1051:                    {
1052:                        if(enable)
1053:                        {
1054:                            DMACONSET=_DMACON_ON_MASK;
1055:                        }
1056:                        else
1057:                        {
1058:                            DMACONCLR=_DMACON_ON_MASK;
1059:                            while(DMACONbits.ON);       // wait to take effect
1060:                        }
1061:                    }
1062:                
1063:                    /*********************************************************************
1064:                     * Function:        void DmaReset(void)
1065:                     *
1066:                     * PreCondition:    None
1067:                     *
1068:                     * Input:       None
1069:                     *
1070:                     * Output:          None
1071:                     *
1072:                     * Side Effects:    None
1073:                     *
1074:                     * Overview:        The function resets the DMA controller.
1075:                     *
1076:                     * Note:            None.
1077:                     *
1078:                     * Example:        DmaReset();
1079:                     ********************************************************************/
1080:                    #define            DmaReset()   DmaEnable(0)
1081:                
1082:                
1083:                    /*********************************************************************
1084:                     * Function:        int DmaSuspend(void)
1085:                     *
1086:                     * PreCondition:    None
1087:                     *
1088:                     * Input:       None
1089:                     *
1090:                     * Output:          true if the DMA was previously suspended, false otherwise
1091:                     *
1092:                     *
1093:                     * Side Effects:    None
1094:                     *
1095:                     * Overview:        The function suspends the DMA controller.
1096:                     *
1097:                     * Note:            After the execution of this function the DMA operation is supposed to be suspended.
1098:                     *                  I.e. the function has to wait for the suspension to take place!
1099:                     *
1100:                     * Example:         int susp=DmaSuspend();
1101:                     ********************************************************************/
1102:                        extern __inline__ int __attribute__((always_inline)) DmaSuspend(void)
1103:                    {
1104:                        int suspSt;
1105:                        if(!(suspSt=DMACONbits.SUSPEND))
9D00092C  3C02BF88   LUI V0, -16504
9D000930  8C423000   LW V0, 12288(V0)
9D000934  7C420300   EXT V0, V0, 12, 1
9D000938  304200FF   ANDI V0, V0, 255
9D00093C  AFC20030   SW V0, 48(S8)
9D000940  8FC20030   LW V0, 48(S8)
9D000944  14400009   BNE V0, ZERO, 0x9D00096C
9D000948  00000000   NOP
9D000A00  3C02BF88   LUI V0, -16504
9D000A04  8C423000   LW V0, 12288(V0)
9D000A08  7C420300   EXT V0, V0, 12, 1
9D000A0C  304200FF   ANDI V0, V0, 255
9D000A10  AFC2003C   SW V0, 60(S8)
9D000A14  8FC2003C   LW V0, 60(S8)
9D000A18  1440000F   BNE V0, ZERO, 0x9D000A58
9D000A1C  00000000   NOP
1106:                        {
1107:                            DMACONSET=_DMACON_SUSPEND_MASK;     // suspend
9D00094C  3C02BF88   LUI V0, -16504
9D000950  24031000   ADDIU V1, ZERO, 4096
9D000954  AC433008   SW V1, 12296(V0)
9D000A20  3C02BF88   LUI V0, -16504
9D000A24  24031000   ADDIU V1, ZERO, 4096
9D000A28  AC433008   SW V1, 12296(V0)
1108:                            while((DMACONbits.DMABUSY));    // wait to be actually suspended
9D000958  3C02BF88   LUI V0, -16504
9D00095C  8C423000   LW V0, 12288(V0)
9D000960  30420800   ANDI V0, V0, 2048
9D000964  1440FFFC   BNE V0, ZERO, 0x9D000958
9D000968  00000000   NOP
9D000A2C  3C02BF88   LUI V0, -16504
9D000A30  8C423000   LW V0, 12288(V0)
9D000A34  30420800   ANDI V0, V0, 2048
9D000A38  1440FFFC   BNE V0, ZERO, 0x9D000A2C
9D000A3C  00000000   NOP
1109:                        }
1110:                        return suspSt;
9D00096C  8FC20030   LW V0, 48(S8)
9D000A40  0B400297   J 0x9D000A5C
9D000A44  00000000   NOP
9D000A58  00000000   NOP
1111:                    }
1112:                
1113:                
1114:                
1115:                    /*********************************************************************
1116:                     * Function:        void DmaResume(int susp)
1117:                     *
1118:                     * PreCondition:    None
1119:                     *
1120:                     * Input:       the desired DMA suspended state.
1121:                     *
1122:                     * Output:          None
1123:                     *
1124:                     * Side Effects:    None
1125:                     *
1126:                     * Overview:        The function restores the DMA controller activity to the old suspended mode.
1127:                     *
1128:                     * Note:            None.
1129:                     *
1130:                     * Example:         int isSusp=DmaSuspend(); {....}; DmaResume(isSusp);
1131:                     ********************************************************************/
1132:                        extern __inline__ void __attribute__((always_inline)) DmaResume(int susp)
1133:                    {
1134:                        if(susp)
9D0009F4  8FC20038   LW V0, 56(S8)
9D0009F8  10400013   BEQ V0, ZERO, 0x9D000A48
9D0009FC  00000000   NOP
1135:                        {
1136:                            DmaSuspend();
1137:                        }
1138:                        else
1139:                        {
1140:                            DMACONCLR=_DMACON_SUSPEND_MASK;     // resume DMA activity
9D000A48  3C02BF88   LUI V0, -16504
9D000A4C  24031000   ADDIU V1, ZERO, 4096
9D000A50  0B400297   J 0x9D000A5C
9D000A54  AC433004   SW V1, 12292(V0)
9D000A58  00000000   NOP
1141:                        }
1142:                    }
1143:                
1144:                    /*********************************************************************
1145:                     * Function:        void DmaGetStatus(DmaStatus* pStat)
1146:                     *
1147:                     * PreCondition:    pStat   - valid pointer
1148:                     *
1149:                     * Input:           pStat   - pointer to a DmaStatus structure to store the current DMA controller
1150:                     *                          status, carrying the following info:
1151:                     *                              - chn:  the last active DMA channel
1152:                     *                              - rdOp: the last DMA operation, read/write
1153:                     *                              - lastAddress: the most recent DMA address
1154:                     *
1155:                     * Output:          None
1156:                     *
1157:                     * Side Effects:    None
1158:                     *
1159:                     * Overview:        The function updates the info for the current DMA controller status.
1160:                     *                  It updates the last DMA: operation, channel used and address.
1161:                     *
1162:                     * Note:            None.
1163:                     *
1164:                     * Example:         DmaStatus stat; DmaGetStatus(&stat);
1165:                     ********************************************************************/
1166:                     void           DmaGetStatus(DmaStatus* pStat);
1167:                
1168:                    /*********************************************************************
1169:                     * Function:        void DmaSetGlobalFlags(DmaGlblFlags gFlags)
1170:                     *
1171:                     * PreCondition:    None
1172:                     *
1173:                     * Input:           gFlags - flags to be set, having the following fields:
1174:                     *          - DMA_GFLG_SUSPEND: DMA controller operation suspend
1175:                     *          - DMA_GFLG_ON: DMA controller enabled/desabled
1176:                     *          - DMA_GFLG_ALL_FLAGS: all flags
1177:                     *
1178:                     * Output:          None
1179:                     *
1180:                     * Side Effects:    None
1181:                     *
1182:                     * Overview:        The function affects the global behavior of the DMA controller.
1183:                     *                  It sets the specified flags. Any flag that is set in the gFlags will be
1184:                     *                  enabled, the other flags won't be touched.
1185:                     *
1186:                     * Note:            None.
1187:                     *
1188:                     * Example:         DmaSetGlobalFlags(DMA_GFLG_ON);
1189:                     ********************************************************************/
1190:                        extern __inline__ void __attribute__((always_inline)) DmaSetGlobalFlags(DmaGlblFlags gFlags)
1191:                    {
1192:                        DMACONSET=gFlags;
1193:                    }
1194:                
1195:                    /*********************************************************************
1196:                     * Function:        void DmaClrGlobalFlags(DmaGlblFlags gFlags)
1197:                     *
1198:                     * PreCondition:    None
1199:                     *
1200:                     * Input:           gFlags - flags to be cleared, having the following fields:
1201:                     *                               - DMA_GFLG_SUSPEND: DMA controller operation suspend
1202:                     *                               - DMA_GFLG_ON: DMA controller enabled/desabled
1203:                     *                               - DMA_GFLG_ALL_FLAGS: all flags
1204:                     *
1205:                     * Output:          None
1206:                     *
1207:                     * Side Effects:    None
1208:                     *
1209:                     * Overview:        The function affects the global behavior of the DMA controller.
1210:                     *                  It clears the specified flags. Any flag that is set in the gFlags will be
1211:                     *                  cleared, the other flags won't be touched.
1212:                     *
1213:                     * Note:            None.
1214:                     *
1215:                     * Example:         DmaClrGlobalFlags(DMA_GFLG_SUSPEND);
1216:                     ********************************************************************/
1217:                        extern __inline__ void __attribute__((always_inline)) DmaClrGlobalFlags(DmaGlblFlags gFlags)
1218:                    {
1219:                        DMACONCLR=gFlags;
1220:                    }
1221:                
1222:                
1223:                    /*********************************************************************
1224:                     * Function:        void DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1225:                     *
1226:                     * PreCondition:    None
1227:                     *
1228:                     * Input:           gFlags - flags to be set, having the following fields:
1229:                     *                                 - DMA_GFLG_SUSPEND: DMA controller operation suspend
1230:                     *                                 - DMA_GFLG_ON: DMA controller enabled/desabled
1231:                     *                                 - DMA_GFLG_ALL_FLAGS: all flags
1232:                     *
1233:                     * Output:          None
1234:                     *
1235:                     * Side Effects:    None
1236:                     *
1237:                     * Overview:        The function affects the global behavior of the DMA controller.
1238:                     *                  It forces the flags to have the specified gFlags value.
1239:                     *
1240:                     * Note:            None.
1241:                     *
1242:                     * Example:         DmaWriteGlobalFlags(DMA_GFLG_ALL_FLAGS);
1243:                     ********************************************************************/
1244:                        extern __inline__ void __attribute__((always_inline)) DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1245:                    {
1246:                        DMACON=gFlags;
1247:                    }
1248:                
1249:                    /*********************************************************************
1250:                     * Function:        DmaGlblFlags DmaGetGlobalFlags(void)
1251:                     *
1252:                     * PreCondition:    None
1253:                     *
1254:                     * Input:           None
1255:                     *
1256:                     * Output:          The current DMA controller flags settings.
1257:                     *                              - DMA_GFLG_SUSPEND: DMA controller operation suspend
1258:                     *                              - DMA_GFLG_ON: DMA controller enabled/desabled
1259:                     *
1260:                     * Side Effects:    None
1261:                     *
1262:                     * Overview:        The function returns the global flags of the DMA controller.
1263:                     *
1264:                     * Note:            None.
1265:                     *
1266:                     * Example:         DmaGlblFlags dmaFlags=DmaGetGlobalFlags();
1267:                     ********************************************************************/
1268:                        extern __inline__ DmaGlblFlags __attribute__((always_inline)) DmaGetGlobalFlags(void)
1269:                    {
1270:                        return (DmaGlblFlags)DMACON;
1271:                    }
1272:                
1273:                
1274:                    /*********************************************************************
1275:                     * Function:        int DmaGetMaxTxferSize(void)
1276:                     *
1277:                     * PreCondition:    None
1278:                     *
1279:                     * Input:           None
1280:                     *
1281:                     * Output:          The maximum transfer capacity for a DMA channel, in bytes.
1282:                     *
1283:                     * Side Effects:    None
1284:                     *
1285:                     * Overview:        The function returns the maximum number of bytes that can be transferred by a DMA channel.
1286:                     *
1287:                     * Note:            Revision dependant.
1288:                     *
1289:                     * Example:         int dmaMaxSz=DmaGetMaxTxferSize();
1290:                     ********************************************************************/
1291:                    extern __inline__ int __attribute__((always_inline)) DmaGetMaxTxferSize(void)
1292:                    {
1293:                        return 65536;
1294:                    }
1295:                
1296:                    // Direct Channel control functions
1297:                
1298:                    typedef enum
1299:                    {
1300:                        DMA_CONFIG_DEFAULT = 0,                             // DMA default operation
1301:                        DMA_CONFIG_AUTO = _DCH0CON_CHAEN_MASK,              // DMA channel is auto enabled
1302:                        DMA_CONFIG_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK), // DMA channel is chained to lower channel
1303:                        DMA_CONFIG_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),       // DMA channel is chained to higher channel
1304:                        DMA_CONFIG_DET_EN = _DCH0CON_CHAED_MASK,            // events detection enabled while channel off
1305:                        DMA_CONFIG_ENABLE = _DCH0CON_CHEN_MASK,             // DMA channel is enabled after open
1306:                        DMA_CONFIG_MATCH    = 0x80000000,                   // DMA channel stops on match
1307:                    }DmaConfigFlags;    // flags for the channel configuration
1308:                
1309:                
1310:                
1311:                    /*********************************************************************
1312:                     * Function:        void DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags)
1313:                     *
1314:                     * PreCondition:    chPri  - valid channel priority, 0-3
1315:                     *
1316:                     * Input:           chn    - channel to be configured in the DMA controller
1317:                     *                  chPri  - the priority given to the channel, 0-3
1318:                     *                  cFlags - orred flags specifying the configuration:
1319:                     *                           DMA_CONFIG_DEFAULT: DMA default operation mode
1320:                     *                           DMA_CONFIG_AUTO:   DMA channel is auto enabled
1321:                     *                           DMA_CONFIG_CHAIN_LOW: DMA channel is chained to lower channel
1322:                     *                           DMA_CONFIG_CHAIN_HI: DMA channel is chained to higher channel
1323:                     *                           DMA_CONFIG_DET_EN: events detection enabled while channel off
1324:                     *                           DMA_CONFIG_ENABLE: DMA channel is enabled when opened
1325:                     *                           DMA_CONFIG_MATCH:  DMA channel stops on match
1326:                     *
1327:                     *
1328:                     *
1329:                     * Output:          None
1330:                     *
1331:                     * Side Effects:    None
1332:                     *
1333:                     * Overview:        The function configures the selected DMA channel using the supplied user flags and priority.
1334:                     *
1335:                     * Note:            - The channel is NOT turned off. It should be turned off before calling this function.
1336:                     *                  The channel is just configured.
1337:                     *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
1338:                     *                  if DMA_CONFIG_ENABLE flag was not specified.
1339:                     *                  - The function does not touch the interrupt flags, interrupt enables, etc.
1340:                     *                  The interrupt flags should have been previously cleared and interrupts disabled before calling this function.
1341:                     *                  - The start and abort Irqs, the channel event enable flags are not touched/cleared by this function.
1342:                     *                  User has to call event channel functions to clear/enable the event flags if needed.
1343:                     *
1344:                     * Example:         DmaChnDisable(DMA_CHANNEL2); DmaChnConfigure(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_CONFIG_AUTO|DMA_CONFIG_MATCH|DMA_CONFIG_ENABLE);
1345:                     ********************************************************************/
1346:                    void            DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags);
1347:                
1348:                
1349:                    /*********************************************************************
1350:                     * Function:        int DmaChnGetSrcPnt(DmaChannel chn)
1351:                     *
1352:                     * PreCondition:    chn - valid DMA channel
1353:                     *
1354:                     * Input:           chn     - DMA channel number
1355:                     *
1356:                     * Output:          Current channel source pointer.
1357:                     *
1358:                     * Side Effects:    None
1359:                     *
1360:                     * Overview:        The function retrieves the current source pointer for the selected DMA channel.
1361:                     *                  It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the source transfer buffer.
1362:                     *
1363:                     * Note:            None
1364:                     *
1365:                     * Example:         int srcPnt=DmaChnGetSrcPnt(DMA_CHANNEL3);
1366:                     ********************************************************************/
1367:                     int            DmaChnGetSrcPnt(DmaChannel chn);
1368:                
1369:                    /*********************************************************************
1370:                     * Function:        int DmaChnGetDstPnt(DmaChannel chn)
1371:                     *
1372:                     * PreCondition:    chn - valid DMA channel
1373:                     *
1374:                     * Input:           chn     - DMA channel number
1375:                     *
1376:                     * Output:          Current channel destination pointer.
1377:                     *
1378:                     * Side Effects:    None
1379:                     *
1380:                     * Overview:        The function retrieves the current destination pointer for the selected DMA channel.
1381:                     *                  It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the destination transfer buffer.
1382:                     *
1383:                     * Note:            None
1384:                     *
1385:                     * Example:         int dstPnt=DmaChnGetDstPnt(DMA_CHANNEL3);
1386:                     ********************************************************************/
1387:                     int            DmaChnGetDstPnt(DmaChannel chn);
1388:                
1389:                    /*********************************************************************
1390:                     * Function:        int DmaChnGetCellPnt(DmaChannel chn)
1391:                     *
1392:                     * PreCondition:    chn - valid DMA channel
1393:                     *
1394:                     * Input:           chn     - DMA channel number
1395:                     *
1396:                     * Output:          Current channel transfer pointer.
1397:                     *
1398:                     * Side Effects:    None
1399:                     *
1400:                     * Overview:        The function retrieves the current transfer progress pointer for the selected DMA channel.
1401:                     *                  It ranges 0 to DmaGetMaxTxferSize()-1.
1402:                     *
1403:                     * Note:            None
1404:                     *
1405:                     * Example:         int cellPnt=DmaChnGetCellPnt(DMA_CHANNEL3);
1406:                     ********************************************************************/
1407:                     int            DmaChnGetCellPnt(DmaChannel chn);
1408:                
1409:                
1410:                
1411:                    /*********************************************************************
1412:                     * Function:        void DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1413:                     *
1414:                     * PreCondition:    chn - valid DMA channel
1415:                     *
1416:                     * Input:           chn         - DMA channel number
1417:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1418:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1419:                     *                                      - SIRQEN: enable/disable the start IRQ action
1420:                     *                                      - PATEN: enable/disable the pattern match and abort
1421:                     *                                  or any of the DmaEvCtrlFlags:
1422:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1423:                     *
1424:                     *
1425:                     * Output:          None
1426:                     *
1427:                     * Side Effects:    None
1428:                     *
1429:                     * Overview:        The function sets the events that start and abort the transfer
1430:                     *                  for the selected DMA channel.
1431:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1432:                     *                  enabled for the selected channel, the other channel event flags won't be touched.
1433:                     *
1434:                     * Note:            None.
1435:                     *
1436:                     * Example:         either:
1437:                     *                      DmaChnSetEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN;
1438:                     *                  or:
1439:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.SIRQEN=1;
1440:                     *                      DmaChnSetEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1441:                     *
1442:                     ********************************************************************/
1443:                     void           DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1444:                
1445:                
1446:                    /*********************************************************************
1447:                     * Function:        void DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1448:                     *
1449:                     * PreCondition:    chn - valid DMA channel
1450:                     *
1451:                     * Input:           chn         - DMA channel number
1452:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1453:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1454:                     *                                      - SIRQEN: enable/disable the start IRQ action
1455:                     *                                      - PATEN: enable/disable the pattern match and abort
1456:                     *                                  or any of the DmaEvCtrlFlags:
1457:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1458:                     *
1459:                     *
1460:                     * Output:          None
1461:                     *
1462:                     * Side Effects:    None
1463:                     *
1464:                     * Overview:        The function clears the events that start and abort the transfer
1465:                     *                  for the selected DMA channel.
1466:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1467:                     *                  disabled for the selected channel, the other channel event flags won't be touched.
1468:                     *
1469:                     * Note:            None.
1470:                     *
1471:                     * Example:         either:
1472:                     *                      DmaChnClrEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN);
1473:                     *                  or:
1474:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.AIRQEN=1;
1475:                     *                      DmaChnClrEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1476:                     *
1477:                     ********************************************************************/
1478:                     void           DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1479:                
1480:                
1481:                
1482:                    /*********************************************************************
1483:                     * Function:        void DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1484:                     *
1485:                     * PreCondition:    chn - valid DMA channel
1486:                     *
1487:                     * Input:           chn         - DMA channel number
1488:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1489:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1490:                     *                                      - SIRQEN: enable/disable the start IRQ action
1491:                     *                                      - PATEN: enable/disable the pattern match and abort
1492:                     *                                      - CHSIRQ: IRQ number to start the DMA channel transfer
1493:                     *                                      - CHAIRQ: IRQ number to abort the DMA channel transfer
1494:                     *                                  or any of the DmaEvCtrlFlags:
1495:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1496:                     *
1497:                     *
1498:                     * Output:          None
1499:                     *
1500:                     * Side Effects:    None
1501:                     *
1502:                     * Overview:        The function writes the events that start and abort the transfer
1503:                     *                  for the selected DMA channel.
1504:                     *
1505:                     * Note:            None.
1506:                     *
1507:                     * Example:         either:
1508:                     *                      DmaChnWriteEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1509:                     *                  or:
1510:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1511:                     *                      DmaChnWriteEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1512:                     *
1513:                     ********************************************************************/
1514:                     void           DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1515:                
1516:                
1517:                
1518:                    /*********************************************************************
1519:                     * Function:        void DmaChnSetEventControl(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1520:                     *
1521:                     * PreCondition:    chn - valid DMA channel
1522:                     *
1523:                     * Input:           chn         - DMA channel number
1524:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1525:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1526:                     *                                      - SIRQEN: enable/disable the start IRQ action
1527:                     *                                      - PATEN: enable/disable the pattern match and abort
1528:                     *                                      - CHSIRQ: IRQ number to start the DMA channel transfer
1529:                     *                                      - CHAIRQ: IRQ number to abort the DMA channel transfer
1530:                     *                                  or any of the DmaEvCtrlFlags:
1531:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1532:                     *
1533:                     *
1534:                     * Output:          None
1535:                     *
1536:                     * Side Effects:    None
1537:                     *
1538:                     * Overview:        The function sets the events that start and abort the transfer
1539:                     *                  for the selected DMA channel.
1540:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1541:                     *                  enabled for the selected channel, the other channel event flags won't be touched.
1542:                     *
1543:                     * Note:           A shorter name for DmaChnWriteEventControlFlags();
1544:                     *
1545:                     * Example:         either:
1546:                     *                      DmaChnSetEventControl(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1547:                     *                  or:
1548:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1549:                     *                      DmaChnSetEventControl(DMA_CHANNEL3, evCtrl.w);
1550:                     *
1551:                     ********************************************************************/
1552:                    #define         DmaChnSetEventControl(chn, dmaEvCtrl)   DmaChnWriteEventControlFlags(chn, dmaEvCtrl)
1553:                
1554:                
1555:                    /*********************************************************************
1556:                     * Function:        DmaEvCtrlFlags DmaChnGetEventControl(DmaChannel chn)
1557:                     *
1558:                     * PreCondition:    chn - valid DMA channel
1559:                     *
1560:                     * Input:           chn     - DMA channel number
1561:                     *
1562:                     * Output:          -   either a DmaEvCtrl structure field, carrying the following info:
1563:                     *                          - AIRQEN: enable/disable the abort IRQ action
1564:                     *                          - SIRQEN: enable/disable the start IRQ action
1565:                     *                          - PATEN: enable/disable the pattern match and abort
1566:                     *                          - CHSIRQ: IRQ number to start the DMA channel transfer
1567:                     *                          - CHAIRQ: IRQ number to abort the DMA channel transfer
1568:                     *                      or any of the DmaEvCtrlFlags:
1569:                     *                          DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1570:                     *
1571:                     *
1572:                     * Side Effects:    None
1573:                     *
1574:                     * Overview:        The function retrieves the events that start and abort the transfer
1575:                     *                  for the selected DMA channel.
1576:                     *
1577:                     * Note:            None.
1578:                     *
1579:                     * Example:         either:
1580:                     *                      DmaEvCtrlFlags evCtrlW=DmaChnGetEventControl(DMA_CHANNEL3); if(evCtrlW&DMA_EV_MATCH_EN) {...}
1581:                     *                  or:
1582:                     *                      DmaEvCtrl evCtrl; evCtrl.w=DmaChnGetEventControl(DMA_CHANNEL3); if(evCtrl.PATEN){...}
1583:                     *
1584:                     ********************************************************************/
1585:                     DmaEvCtrlFlags DmaChnGetEventControl(DmaChannel chn);
1586:                
1587:                
1588:                    /*********************************************************************
1589:                     * Function:        void DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1590:                     *
1591:                     * PreCondition:    chn - valid DMA channel
1592:                     *
1593:                     * Input:           chn         - DMA channel number
1594:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1595:                     *                                      - autoEn: enable/disable the automatic mode
1596:                     *                                      - chainEn: enable/disable channel chaining
1597:                     *                                      - detectEn: enable/disable events detection when channel disabled
1598:                     *                                      - chEn: enable/disable channel functionality
1599:                     *                                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1600:                     *                                  or any of the DmaChnCtrlFlags flags:
1601:                     *                                      DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1602:                     *
1603:                     * Output:          None
1604:                     *
1605:                     * Side Effects:    None
1606:                     *
1607:                     * Overview:        The function sets the selected DMA channel control flags:
1608:                     *                  the chaining or auto mode, and events detection.
1609:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1610:                     *                  set for the selected channel, the other channel control flags won't be touched.
1611:                     *
1612:                     * Note:            None.
1613:                     *
1614:                     * Example:         either:
1615:                     *                      DmaChnSetControlFlags(DMA_CHANNEL3, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1616:                     *                  or:
1617:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1618:                     *                      DmaChnSetControlFlags(DMA_CHANNEL3, chCtrl.w);
1619:                     *
1620:                     ********************************************************************/
1621:                     void           DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1622:                
1623:                    /*********************************************************************
1624:                     * Function:        void DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1625:                     *
1626:                     * PreCondition:    chn - valid DMA channel
1627:                     *
1628:                     * Input:           chn         - DMA channel number
1629:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1630:                     *                                      - autoEn: enable/disable the automatic mode
1631:                     *                                      - chainEn: enable/disable channel chaining
1632:                     *                                      - detectEn: enable/disable events detection when channel disabled
1633:                     *                                      - chEn: enable/disable channel functionality
1634:                     *                                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1635:                     *                                  or any of the DmaChnCtrlFlags flags:
1636:                     *                                      DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1637:                     *
1638:                     * Output:          None
1639:                     *
1640:                     * Side Effects:    None
1641:                     *
1642:                     * Overview:        The function clears the selected DMA channel control flags:
1643:                     *                  the chaining or auto mode and events detection.
1644:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1645:                     *                  cleared for the selected channel, the other channel control flags won't be touched.
1646:                     *
1647:                     * Note:            None.
1648:                     *
1649:                     * Example:         either:
1650:                     *                      DmaChnClrControlFlags(DMA_CHANNEL3, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1651:                     *                  or:
1652:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1653:                     *                      DmaChnClrControlFlags(DMA_CHANNEL3, chCtrl.w);
1654:                     *
1655:                     ********************************************************************/
1656:                     void           DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1657:                
1658:                    /*********************************************************************
1659:                     * Function:        void DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1660:                     *
1661:                     * PreCondition:    chn - valid DMA channel
1662:                     *
1663:                     * Input:           chn         - DMA channel number
1664:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1665:                     *                                      - chPri: channel priority 0-3
1666:                     *                                      - autoEn: enable/disable the automatic mode
1667:                     *                                      - chainEn: enable/disable channel chaining
1668:                     *                                      - detectEn: enable/disable events detection when channel disabled
1669:                     *                                      - chEn: enable/disable channel functionality
1670:                     *                                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1671:                     *                                  or any of the DmaChnCtrlFlags flags:
1672:                     *                                      DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1673:                     *
1674:                     * Output:          None
1675:                     *
1676:                     * Side Effects:    None
1677:                     *
1678:                     * Overview:        The function enables/disables the selected DMA channel and also sets
1679:                     *                  the channel priority, chaining mode or auto and events detection.
1680:                     *
1681:                     * Note:            None.
1682:                     *
1683:                     * Example:         either:
1684:                     *                      DmaChnWriteControlFlags(DMA_CHANNEL3, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1685:                     *                  or:
1686:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1687:                     *                      DmaChnWriteControlFlags(DMA_CHANNEL3, chCtrl.w);
1688:                     *
1689:                     ********************************************************************/
1690:                     void           DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1691:                
1692:                    /*********************************************************************
1693:                     * Function:        void DmaChnSetControl(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1694:                     *
1695:                     * PreCondition:    chn - valid DMA channel
1696:                     *
1697:                     * Input:       chn     - DMA channel number
1698:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1699:                     *                      - chPri: channel priority 0-3
1700:                     *                      - autoEn: enable/disable the automatic mode
1701:                     *                      - chainEn: enable/disable channel chaining
1702:                     *                      - detectEn: enable/disable events detection when channel disabled
1703:                     *                      - chEn: enable/disable channel functionality
1704:                     *                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1705:                     *                  or any of the DmaChnCtrlFlags flags:
1706:                     *                      DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1707:                     *
1708:                     * Output:          None
1709:                     *
1710:                     * Side Effects:    None
1711:                     *
1712:                     * Overview:        The function enables/disables the selected DMA channel and also sets
1713:                     *                  the channel priority, chaining mode or auto and events detection.
1714:                     *
1715:                     * Note:            Another name ( backward compatible) for DmaChnWriteControlFlags().
1716:                     *
1717:                     * Example:         either:
1718:                     *                      DmaChnSetControl(DMA_CHANNEL3, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1719:                     *                  or:
1720:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1721:                     *          DmaChnSetControl(DMA_CHANNEL3, chCtrl.w);
1722:                     *
1723:                     ********************************************************************/
1724:                    #define     DmaChnSetControl(chn, dmaChnCtrl)   DmaChnWriteControlFlags(chn, dmaChnCtrl)
1725:                
1726:                    /*********************************************************************
1727:                     * Function:        DmaChnCtrlFlags DmaChnGetControlFlags(DmaChannel chn)
1728:                     *
1729:                     * PreCondition:    chn - valid DMA channel
1730:                     *
1731:                     * Input:           chn         - DMA channel number
1732:                     *
1733:                     * Output:          - either a DmaChnCtrl structure field, carrying the following info:
1734:                     *                          - chPri: channel priority 0-3
1735:                     *                          - autoEn: enable/disable the automatic mode
1736:                     *                          - chainEn: enable/disable channel chaining
1737:                     *                          - detectEn: enable/disable events detection when channel disabled
1738:                     *                          - chEn: enable/disable channel functionality
1739:                     *                          - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1740:                     *                      or any of the DmaChnCtrlFlags flags:
1741:                     *                          DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1742:                     *
1743:                     * Side Effects:    None
1744:                     *
1745:                     * Overview:        The function retrieves the current control settings for the selected DMA channel,
1746:                     *                  including the channel enable/disable status, the channel priority,
1747:                     *                  chaining mode, auto mode and events detection.
1748:                     *
1749:                     * Note:            None.
1750:                     *
1751:                     * Example:         either:
1752:                     *                      DmaChnCtrlFlags ctrl=DmaChnGetControlFlags(DMA_CHANNEL3); if(ctrl&DMA_CTL_AUTO_EN) {...}
1753:                     *                  or:
1754:                     *                      DmaChnCtrl chnCtrl; chnCtrl.w=DmaChnGetControlFlags(DMA_CHANNEL3); if(chnCtrl.autoEn) {...}
1755:                     *
1756:                     ********************************************************************/
1757:                     DmaChnCtrlFlags    DmaChnGetControlFlags(DmaChannel chn);
1758:                
1759:                
1760:                    /*********************************************************************
1761:                     * Function:        int DmaChnGetEvDetect(DmaChannel chn)
1762:                     *
1763:                     * PreCondition:    chn - valid DMA channel
1764:                     *
1765:                     * Input:           chn     - DMA channel number
1766:                     *
1767:                     * Output:          TRUE if an DMA event was detected, FALSE otherwise.
1768:                     *
1769:                     * Side Effects:    None
1770:                     *
1771:                     * Overview:        The function returns the current event detection for the selected DMA channel.
1772:                     *
1773:                     * Note:            None.
1774:                     *
1775:                     * Example:         int evDetect=DmaChnGetEvDetect(DMA_CHANNEL3);
1776:                     *
1777:                     ********************************************************************/
1778:                     int            DmaChnGetEvDetect(DmaChannel chn);
1779:                
1780:                    /*********************************************************************
1781:                     * Function:        void DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0)
1782:                     *
1783:                     * PreCondition:    chn     - valid DMA channel
1784:                     *                  pTxCtrl - valid pointer
1785:                     *
1786:                     * Input:           chn         - DMA channel number
1787:                     *                  pTxCtrl     - pointer to a DmaTxferCtrl that will carry the following info:
1788:                     *                              - vSrcAdd: source of the DMA transfer
1789:                     *                              - vDstAdd: destination of the DMA transfer
1790:                     *                              - srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
1791:                     *                              - dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
1792:                     *                              - cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
1793:                     *                  mapToK0     - if TRUE, a Kernel address is mapped to KSeg0, else KSeg1.
1794:                     *
1795:                     * Output:          None
1796:                     *
1797:                     * Side Effects:    None
1798:                     *
1799:                     * Overview:        The function retrieves the transfer characteristics for a DMA channel transfer:
1800:                     *                  the source and the destination addresses.
1801:                     *                  It also retrieves the source and destination lengths
1802:                     *                  and the number of bytes transferred per event.
1803:                     *
1804:                     * Note:            None
1805:                     *
1806:                     * Example:         DmaTxferCtrl txCtl; DmaChnGetTxfer(DMA_CHANNEL3, &txCtl, FALSE);
1807:                     ********************************************************************/
1808:                     void           DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0);
1809:                
1810:                    // Low level checksum functions
1811:                
1812:                    /*********************************************************************
1813:                     * Function:        void DmaSfmEnable(int enable)
1814:                     *
1815:                     * PreCondition:    None
1816:                     *
1817:                     * Input:           enable _ boolean to enable/disable the SFM functionality
1818:                     *
1819:                     * Output:          None
1820:                     *
1821:                     * Side Effects:    None
1822:                     *
1823:                     * Overview:        The function enables/diables the checksum module functionality.
1824:                     *                  When enabled the attached DMA channel transfers are routed to the SFM module.
1825:                     *
1826:                     * Note:            The SFM module should be properly configured before enabled.
1827:                     *
1828:                     * Example:         DmaSfmEnable(1);
1829:                     ********************************************************************/
1830:                    extern __inline__ void __attribute__((always_inline)) DmaSfmEnable(int enable)
1831:                    {
1832:                        if(enable)
1833:                        {
1834:                            DCRCCONSET=_DCRCCON_CRCEN_MASK;
1835:                        }
1836:                        else
1837:                        {
1838:                            DCRCCONCLR=_DCRCCON_CRCEN_MASK;
1839:                        }
1840:                    }
1841:                    #define DmaCrcEnable    DmaSfmEnable        // PIC32_3xx backward compatibility
1842:                
1843:                
1844:                    /*********************************************************************
1845:                     * Function:        int DmaSfmGetEnable(void)
1846:                     *
1847:                     * PreCondition:    None
1848:                     *
1849:                     * Input:           None
1850:                     *
1851:                     * Output:          TRUE, if the SFM module is enabled
1852:                     *          FALSE otherwise
1853:                     *
1854:                     * Side Effects:    None
1855:                     *
1856:                     * Overview:        The function returns the SFM module enabling status.
1857:                     *
1858:                     * Note:            None
1859:                     *
1860:                     * Example:     int isSfmEnabled=DmaSfmGetEnable();
1861:                     ********************************************************************/
1862:                    extern __inline__ int __attribute__((always_inline)) DmaSfmGetEnable(void)
1863:                    {
1864:                        return DCRCCONbits.CRCEN!=0;
1865:                    }
1866:                    #define     DmaCrcGetEnable     DmaSfmGetEnable     // PIC32_3xx backward compatibility
1867:                
1868:                
1869:                    /*********************************************************************
1870:                     * Function:        void DmaSfmAppendEnable(int enable)
1871:                     *
1872:                     * PreCondition:    None
1873:                     *
1874:                     * Input:           enable _ boolean to enable/disable the SFM append mode
1875:                     *
1876:                     * Output:          None
1877:                     *
1878:                     * Side Effects:    None
1879:                     *
1880:                     * Overview:        The function enables the SFM append mode. In this mode, the attached DMA channel reads
1881:                     *                  the source data but does not write it to the destination address. The data it's just passed
1882:                     *                  to the checksum generator for CRC/IP checksum calculation.
1883:                     *                  When the block transfer is completed, the checksum result is written to the
1884:                     *                  DMA channel destination address.
1885:                     *
1886:                     * Note:            The SFM module should be properly configured before enabled.
1887:                     *
1888:                     * Example:         DmaSfmAppendModeEnable(TRUE);
1889:                     ********************************************************************/
1890:                    extern __inline__ void __attribute__((always_inline)) DmaSfmAppendEnable(int enable)
1891:                    {
1892:                        if(enable)
1893:                        {
1894:                            DCRCCONSET=_DCRCCON_CRCAPP_MASK;
1895:                        }
1896:                        else
1897:                        {
1898:                            DCRCCONCLR=_DCRCCON_CRCAPP_MASK;
1899:                        }
1900:                    }
1901:                    #define     DmaCrcAppendModeEnable  DmaSfmAppendEnable  // PIC32_3xx backward compatibility
1902:                
1903:                
1904:                    /*********************************************************************
1905:                     * Function:        int DmaSfmGetAppendMode(void)
1906:                     *
1907:                     * PreCondition:    None
1908:                     *
1909:                     * Input:           None
1910:                     *
1911:                     * Output:          TRUE, if the SFM append mode is enabled
1912:                     *                  FALSE otherwise
1913:                     *
1914:                     * Side Effects:    None
1915:                     *
1916:                     * Overview:        The function returns the SFM module enabling status.
1917:                     *
1918:                     * Note:            None
1919:                     *
1920:                     * Example:         int isAppendEnabled=DmaSfmGetAppendMode();
1921:                     ********************************************************************/
1922:                    extern __inline__ int __attribute__((always_inline)) DmaSfmGetAppendMode(void)
1923:                    {
1924:                        return DCRCCONbits.CRCAPP!=0;
1925:                    }
1926:                    #define DmaCrcGetAppendMode DmaSfmGetAppendMode     // PIC32_3xx backward compatibility
1927:                
1928:                
1929:                    /*********************************************************************
1930:                     * Function:        void DmaSfmSetAttach(DmaChannel chn)
1931:                     *
1932:                     * PreCondition:    chn     - valid DMA channel
1933:                     *
1934:                     * Input:           chn - the DMA channel to be attached to the SFM module (the DMA channel transfers will be routed to the SFM module)
1935:                     *
1936:                     * Output:          None
1937:                     *
1938:                     * Side Effects:    None
1939:                     *
1940:                     * Overview:        The function directly attaches a DMA channel to the SFM module.
1941:                     *
1942:                     * Note:            None
1943:                     *
1944:                     * Example:         DmaSfmSetAttach(DMA_CHANNEL3);
1945:                     ********************************************************************/
1946:                    extern __inline__ void __attribute__((always_inline)) DmaSfmSetAttach(DmaChannel chn)
1947:                    {
1948:                        DCRCCONCLR=_DCRCCON_CRCCH_MASK;
1949:                        DCRCCONSET=chn;
1950:                    }
1951:                    #define     DmaCrcSetAttach     DmaSfmSetAttach     // PIC32_3xx backward compatibility
1952:                
1953:                
1954:                    /*********************************************************************
1955:                     * Function:        DmaChannel DmaSfmGetAttach(void)
1956:                     *
1957:                     * PreCondition:    None
1958:                     *
1959:                     * Input:           None
1960:                     *
1961:                     * Output:          the DMA channel that is currently attached to the CRC module
1962:                     *
1963:                     * Side Effects:    None
1964:                     *
1965:                     * Overview:        The function returns the DMA channel number that is currently attached to the SFM module.
1966:                     *
1967:                     * Note:            None
1968:                     *
1969:                     * Example:         DmaChannel chn=DmaSfmGetAttach();
1970:                     ********************************************************************/
1971:                    extern __inline__ DmaChannel __attribute__((always_inline)) DmaSfmGetAttach(void)
1972:                    {
1973:                        return (DmaChannel)DCRCCONbits.CRCCH;
1974:                    }
1975:                    #define     DmaCrcGetAttach     DmaSfmGetAttach     // PIC32_3xx backward compatibility
1976:                
1977:                    /*********************************************************************
1978:                     * Function:        void DmaCrcSetPLen(int pLen)
1979:                     *
1980:                     * PreCondition:    pLen - valid polynomial length within 1-32
1981:                     *
1982:                     * Input:           pLen    - the length of the CRC generator polynomial
1983:                     *
1984:                     * Output:          None
1985:                     *
1986:                     * Side Effects:    None
1987:                     *
1988:                     * Overview:        The length of the CRC generator polynomial is set as being pLen;
1989:                     *
1990:                     * Note:            None
1991:                     *
1992:                     * Example:         DmaCrcSetPLen(32);
1993:                     ********************************************************************/
1994:                    extern __inline__ void __attribute__((always_inline)) DmaCrcSetPLen(int pLen)
1995:                    {
1996:                        DCRCCONCLR=_DCRCCON_PLEN_MASK;
1997:                        DCRCCONSET=(pLen)-1;
1998:                    }
1999:                
2000:                    /*********************************************************************
2001:                     * Function:        int DmaCrcGetPLen(void)
2002:                     *
2003:                     * PreCondition:    None
2004:                     *
2005:                     * Input:           None
2006:                     *
2007:                     * Output:          the length of the CRC generator polynomial
2008:                     *
2009:                     * Side Effects:    None
2010:                     *
2011:                     * Overview:        The function returns the current length of the CRC generator polynomial.
2012:                     *                  It's always a number between 1 and 32.
2013:                     *
2014:                     * Note:            None
2015:                     *
2016:                     * Example:         int polyLen=DmaCrcGetPLen();
2017:                     ********************************************************************/
2018:                    extern __inline__ int __attribute__((always_inline)) DmaCrcGetPLen(void)
2019:                    {
2020:                        return  DCRCCONbits.PLEN+1;
2021:                    }
2022:                
2023:                    /*********************************************************************
2024:                     * Function:        void DmaCrcSetShiftFeedback(unsigned int feedback)
2025:                     *
2026:                     * PreCondition:    None
2027:                     *
2028:                     * Input:           feedback - the layout of the CRC generator
2029:                     *
2030:                     * Output:          None
2031:                     *
2032:                     * Side Effects:    None
2033:                     *
2034:                     * Overview:        The function sets the layout of the shift stages that take place in the CRC generation.
2035:                     *                  Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
2036:                     *                  If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
2037:                     *
2038:                     * Note:            Bit 0 of the generator polynomial is always XOR'ed.
2039:                     *
2040:                     * Example:         DmaCrcSetShiftFeedback(0x04c11db7);
2041:                     ********************************************************************/
2042:                    extern __inline__ void __attribute__((always_inline)) DmaCrcSetShiftFeedback(unsigned int feedback)
2043:                    {
2044:                        DCRCXOR=feedback;
2045:                    }
2046:                
2047:                
2048:                    /*********************************************************************
2049:                     * Function:        unsigned int DmaCrcGetShiftFeedback(void)
2050:                     *
2051:                     * PreCondition:    None
2052:                     *
2053:                     * Input:           None
2054:                     *
2055:                     * Output:          the current layout of the CRC generator
2056:                     *
2057:                     * Side Effects:    None
2058:                     *
2059:                     * Overview:        The function returns the layout of the shift stages that take place in the CRC generation.
2060:                     *                  A bit set to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
2061:                     *                  If a bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
2062:                     *
2063:                     * Note:            Bit 0 of the generator polynomial is always XOR'ed.
2064:                     *
2065:                     * Example:         int feedback=DmaCrcGetShiftFeedback();
2066:                     ********************************************************************/
2067:                    extern __inline__ unsigned int __attribute__((always_inline)) DmaCrcGetShiftFeedback(void)
2068:                    {
2069:                        return DCRCXOR;
2070:                    }
2071:                
2072:                
2073:                
2074:                    // Channel test/debug and special functions
2075:                
2076:                    /*********************************************************************
2077:                     * Function:        void DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2078:                     *
2079:                     * PreCondition:    chn - valid DMA channel
2080:                     *
2081:                     * Input:           chn     - DMA channel number
2082:                     *                  eFlags  - event flags with the following significance:
2083:                     *                              - DMA_EV_ERR: address error event
2084:                     *                              - DMA_EV_ABORT: transfer abort event
2085:                     *                              - DMA_EV_CELL_DONE: cell transfer complete event
2086:                     *                              - DMA_EV_BLOCK_DONE: block transfer complete event
2087:                     *                              - DMA_EV_DST_HALF: destination half event
2088:                     *                              - DMA_EV_DST_FULL: destination full event
2089:                     *                              - DMA_EV_SRC_HALF: source half event
2090:                     *                              - DMA_EV_SRC_FULL: source full event
2091:                     *                              - DMA_EV_ALL_EVNTS: all of the above flags
2092:                     *
2093:                     * Output:          None
2094:                     *
2095:                     * Side Effects:    None
2096:                     *
2097:                     * Overview:        The function sets the event flags for the selected DMA channel.
2098:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
2099:                     *                  set for the selected channel, the other channel event flags won't be touched.
2100:                     *
2101:                     * Note:            This is intended as a channel test function.
2102:                     *
2103:                     * Example:         DmaChnSetEvFlags(DMA_CHANNEL0, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2104:                     ********************************************************************/
2105:                     void           DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2106:                
2107:                    /*********************************************************************
2108:                     * Function:        void DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2109:                     *
2110:                     * PreCondition:    chn - valid DMA channel
2111:                     *
2112:                     * Input:           chn     - DMA channel number
2113:                     *                  eFlags  - event flags with the following significance:
2114:                     *                              - DMA_EV_ERR: address error event
2115:                     *                              - DMA_EV_ABORT: transfer abort event
2116:                     *                              - DMA_EV_CELL_DONE: cell transfer complete event
2117:                     *                              - DMA_EV_BLOCK_DONE: block transfer complete event
2118:                     *                              - DMA_EV_DST_HALF: destination half event
2119:                     *                              - DMA_EV_DST_FULL: destination full event
2120:                     *                              - DMA_EV_SRC_HALF: source half event
2121:                     *                              - DMA_EV_SRC_FULL: source full event
2122:                     *                              - DMA_EV_ALL_EVNTS: all of the above flags
2123:                     *
2124:                     * Output:          None
2125:                     *
2126:                     * Side Effects:    None
2127:                     *
2128:                     * Overview:        The function writes the event flags for the selected DMA channel.
2129:                     *                  The channel event flags are forced to the eFlags value.
2130:                     *
2131:                     * Note:            This is intended as a channel test function.
2132:                     *
2133:                     * Example:         DmaChnWriteEvFlags(DMA_CHANNEL0, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2134:                     ********************************************************************/
2135:                     void           DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2136:                
2137:                
2138:                    /********************************************************************
2139:                     * Include legacy DMA functions
2140:                     * New projects should not use them!
2141:                     * Note that interrupt functions are no longer provided.
2142:                     * The functions in the int.h should be used instead.
2143:                     ********************************************************************/
2144:                    #ifndef _PLIB_DISABLE_LEGACY
2145:                        #include <peripheral/legacy/dma_legacy.h>
2146:                    #endif
2147:                
2148:                
2149:                #else
2150:                    #undef _DMA_CHANNELS        // no DMA channels
2151:                #endif  // _DMAC0
2152:                
2153:                #endif /*_DMA_H_*/
2154:                
2155:                
